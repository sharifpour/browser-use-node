"Allways refer this python original lib code as the ultimate logic ref for this lib"


{
  "browser_use/logging_config.py": {
    "isBinary": "false",
    "code": "import logging\nimport os\nimport sys\n\n\ndef addLoggingLevel(levelName, levelNum, methodName=None):\n\t\"\"\"\n\tComprehensively adds a new logging level to the `logging` module and the\n\tcurrently configured logging class.\n\n\t`levelName` becomes an attribute of the `logging` module with the value\n\t`levelNum`. `methodName` becomes a convenience method for both `logging`\n\titself and the class returned by `logging.getLoggerClass()` (usually just\n\t`logging.Logger`). If `methodName` is not specified, `levelName.lower()` is\n\tused.\n\n\tTo avoid accidental clobberings of existing attributes, this method will\n\traise an `AttributeError` if the level name is already an attribute of the\n\t`logging` module or if the method name is already present\n\n\tExample\n\t-------\n\t>>> addLoggingLevel('TRACE', logging.DEBUG - 5)\n\t>>> logging.getLogger(__name__).setLevel('TRACE')\n\t>>> logging.getLogger(__name__).trace('that worked')\n\t>>> logging.trace('so did this')\n\t>>> logging.TRACE\n\t5\n\n\t\"\"\"\n\tif not methodName:\n\t\tmethodName = levelName.lower()\n\n\tif hasattr(logging, levelName):\n\t\traise AttributeError('{} already defined in logging module'.format(levelName))\n\tif hasattr(logging, methodName):\n\t\traise AttributeError('{} already defined in logging module'.format(methodName))\n\tif hasattr(logging.getLoggerClass(), methodName):\n\t\traise AttributeError('{} already defined in logger class'.format(methodName))\n\n\t# This method was inspired by the answers to Stack Overflow post\n\t# http://stackoverflow.com/q/2183233/2988730, especially\n\t# http://stackoverflow.com/a/13638084/2988730\n\tdef logForLevel(self, message, *args, **kwargs):\n\t\tif self.isEnabledFor(levelNum):\n\t\t\tself._log(levelNum, message, args, **kwargs)\n\n\tdef logToRoot(message, *args, **kwargs):\n\t\tlogging.log(levelNum, message, *args, **kwargs)\n\n\tlogging.addLevelName(levelNum, levelName)\n\tsetattr(logging, levelName, levelNum)\n\tsetattr(logging.getLoggerClass(), methodName, logForLevel)\n\tsetattr(logging, methodName, logToRoot)\n\n\ndef setup_logging():\n\t# Try to add RESULT level, but ignore if it already exists\n\ttry:\n\t\taddLoggingLevel('RESULT', 35)  # This allows ERROR, FATAL and CRITICAL\n\texcept AttributeError:\n\t\tpass  # Level already exists, which is fine\n\n\tlog_type = os.getenv('BROWSER_USE_LOGGING_LEVEL', 'info').lower()\n\n\t# Check if handlers are already set up\n\tif logging.getLogger().hasHandlers():\n\t\treturn\n\n\t# Clear existing handlers\n\troot = logging.getLogger()\n\troot.handlers = []\n\n\tclass BrowserUseFormatter(logging.Formatter):\n\t\tdef format(self, record):\n\t\t\tif record.name.startswith('browser_use.'):\n\t\t\t\trecord.name = record.name.split('.')[-2]\n\t\t\treturn super().format(record)\n\n\t# Setup single handler for all loggers\n\tconsole = logging.StreamHandler(sys.stdout)\n\n\t# adittional setLevel here to filter logs\n\tif log_type == 'result':\n\t\tconsole.setLevel('RESULT')\n\t\tconsole.setFormatter(BrowserUseFormatter('%(message)s'))\n\telse:\n\t\tconsole.setFormatter(BrowserUseFormatter('%(levelname)-8s [%(name)s] %(message)s'))\n\n\t# Configure root logger only\n\troot.addHandler(console)\n\n\t# switch cases for log_type\n\tif log_type == 'result':\n\t\troot.setLevel('RESULT')  # string usage to avoid syntax error\n\telif log_type == 'debug':\n\t\troot.setLevel(logging.DEBUG)\n\telse:\n\t\troot.setLevel(logging.INFO)\n\n\t# Configure browser_use logger\n\tbrowser_use_logger = logging.getLogger('browser_use')\n\tbrowser_use_logger.propagate = False  # Don't propagate to root logger\n\tbrowser_use_logger.addHandler(console)\n\tbrowser_use_logger.setLevel(root.level)  # Set same level as root logger\n\n\tlogger = logging.getLogger('browser_use')\n\tlogger.info('BrowserUse logging setup complete with level %s', log_type)\n\t# Silence third-party loggers\n\tfor logger in [\n\t\t'WDM',\n\t\t'httpx',\n\t\t'selenium',\n\t\t'playwright',\n\t\t'urllib3',\n\t\t'asyncio',\n\t\t'langchain',\n\t\t'openai',\n\t\t'httpcore',\n\t\t'charset_normalizer',\n\t]:\n\t\tthird_party = logging.getLogger(logger)\n\t\tthird_party.setLevel(logging.ERROR)\n\t\tthird_party.propagate = False\n"
  },
  "browser_use/.DS_Store": {
    "code": "",
    "isBinary": "true"
  },
  "browser_use/browser/context.py": {
    "code": "\"\"\"\nPlaywright browser on steroids.\n\"\"\"\n\nimport asyncio\nimport base64\nimport json\nimport logging\nimport os\nimport re\nimport time\nimport uuid\nfrom dataclasses import dataclass, field\nfrom typing import TYPE_CHECKING, Optional, TypedDict\n\nfrom playwright.async_api import Browser as PlaywrightBrowser\nfrom playwright.async_api import (\n\tBrowserContext as PlaywrightBrowserContext,\n)\nfrom playwright.async_api import (\n\tElementHandle,\n\tFrameLocator,\n\tPage,\n)\n\nfrom browser_use.browser.views import BrowserError, BrowserState, TabInfo\nfrom browser_use.dom.service import DomService\nfrom browser_use.dom.views import DOMElementNode, SelectorMap\nfrom browser_use.utils import time_execution_sync\n\nif TYPE_CHECKING:\n\tfrom browser_use.browser.browser import Browser\n\nlogger = logging.getLogger(__name__)\n\n\nclass BrowserContextWindowSize(TypedDict):\n\twidth: int\n\theight: int\n\n\n@dataclass\nclass BrowserContextConfig:\n\t\"\"\"\n\tConfiguration for the BrowserContext.\n\n\tDefault values:\n\t\tcookies_file: None\n\t\t\tPath to cookies file for persistence\n\n\t        disable_security: False\n\t                Disable browser security features\n\n\t\tminimum_wait_page_load_time: 0.5\n\t\t\tMinimum time to wait before getting page state for LLM input\n\n\t        wait_for_network_idle_page_load_time: 1.0\n\t                Time to wait for network requests to finish before getting page state.\n\t                Lower values may result in incomplete page loads.\n\n\t\tmaximum_wait_page_load_time: 5.0\n\t\t\tMaximum time to wait for page load before proceeding anyway\n\n\t\twait_between_actions: 1.0\n\t\t\tTime to wait between multiple per step actions\n\n\t\tbrowser_window_size: {\n\t\t\t\t'width': 1280,\n\t\t\t\t'height': 1100,\n\t\t\t}\n\t\t\tDefault browser window size\n\n\t\tno_viewport: False\n\t\t\tDisable viewport\n\t\tsave_recording_path: None\n\t\t\tPath to save video recordings\n\n\t\ttrace_path: None\n\t\t\tPath to save trace files. It will auto name the file with the TRACE_PATH/{context_id}.zip\n\t\"\"\"\n\n\tcookies_file: str | None = None\n\tminimum_wait_page_load_time: float = 0.5\n\twait_for_network_idle_page_load_time: float = 1\n\tmaximum_wait_page_load_time: float = 5\n\twait_between_actions: float = 1\n\n\tdisable_security: bool = False\n\n\tbrowser_window_size: BrowserContextWindowSize = field(\n\t\tdefault_factory=lambda: {'width': 1280, 'height': 1100}\n\t)\n\tno_viewport: Optional[bool] = None\n\n\tsave_recording_path: str | None = None\n\ttrace_path: str | None = None\n\n\n@dataclass\nclass BrowserSession:\n\tcontext: PlaywrightBrowserContext\n\tcurrent_page: Page\n\tcached_state: BrowserState\n\n\nclass BrowserContext:\n\tdef __init__(\n\t\tself,\n\t\tbrowser: 'Browser',\n\t\tconfig: BrowserContextConfig = BrowserContextConfig(),\n\t):\n\t\tself.context_id = str(uuid.uuid4())\n\t\tlogger.debug(f'Initializing new browser context with id: {self.context_id}')\n\n\t\tself.config = config\n\t\tself.browser = browser\n\n\t\t# Initialize these as None - they'll be set up when needed\n\t\tself.session: BrowserSession | None = None\n\n\tasync def __aenter__(self):\n\t\t\"\"\"Async context manager entry\"\"\"\n\t\tawait self._initialize_session()\n\t\treturn self\n\n\tasync def __aexit__(self, exc_type, exc_val, exc_tb):\n\t\t\"\"\"Async context manager exit\"\"\"\n\t\tawait self.close()\n\n\tasync def close(self):\n\t\t\"\"\"Close the browser instance\"\"\"\n\t\tlogger.debug('Closing browser context')\n\n\t\ttry:\n\t\t\t# check if already closed\n\t\t\tif self.session is None:\n\t\t\t\treturn\n\n\t\t\tawait self.save_cookies()\n\n\t\t\tif self.config.trace_path:\n\t\t\t\ttry:\n\t\t\t\t\tawait self.session.context.tracing.stop(\n\t\t\t\t\t\tpath=os.path.join(self.config.trace_path, f'{self.context_id}.zip')\n\t\t\t\t\t)\n\t\t\t\texcept Exception as e:\n\t\t\t\t\tlogger.debug(f'Failed to stop tracing: {e}')\n\n\t\t\ttry:\n\t\t\t\tawait self.session.context.close()\n\t\t\texcept Exception as e:\n\t\t\t\tlogger.debug(f'Failed to close context: {e}')\n\t\tfinally:\n\t\t\tself.session = None\n\n\tdef __del__(self):\n\t\t\"\"\"Cleanup when object is destroyed\"\"\"\n\t\tif self.session is not None:\n\t\t\tlogger.debug('BrowserContext was not properly closed before destruction')\n\t\t\ttry:\n\t\t\t\t# Use sync Playwright method for force cleanup\n\t\t\t\tif hasattr(self.session.context, '_impl_obj'):\n\t\t\t\t\tasyncio.run(self.session.context._impl_obj.close())\n\t\t\t\tself.session = None\n\t\t\texcept Exception as e:\n\t\t\t\tlogger.warning(f'Failed to force close browser context: {e}')\n\n\tasync def _initialize_session(self):\n\t\t\"\"\"Initialize the browser session\"\"\"\n\t\tlogger.debug('Initializing browser context')\n\n\t\tplaywright_browser = await self.browser.get_playwright_browser()\n\n\t\tcontext = await self._create_context(playwright_browser)\n\t\tpage = await context.new_page()\n\n\t\t# Instead of calling _update_state(), create an empty initial state\n\t\tinitial_state = BrowserState(\n\t\t\telement_tree=DOMElementNode(\n\t\t\t\ttag_name='root',\n\t\t\t\tis_visible=True,\n\t\t\t\tparent=None,\n\t\t\t\txpath='',\n\t\t\t\tattributes={},\n\t\t\t\tchildren=[],\n\t\t\t),\n\t\t\tselector_map={},\n\t\t\turl=page.url,\n\t\t\ttitle=await page.title(),\n\t\t\tscreenshot=None,\n\t\t\ttabs=[],\n\t\t)\n\n\t\tself.session = BrowserSession(\n\t\t\tcontext=context,\n\t\t\tcurrent_page=page,\n\t\t\tcached_state=initial_state,\n\t\t)\n\n\t\tawait self._add_new_page_listener(context)\n\n\t\treturn self.session\n\n\tasync def _add_new_page_listener(self, context: PlaywrightBrowserContext):\n\t\tasync def on_page(page: Page):\n\t\t\tawait page.wait_for_load_state()\n\t\t\tlogger.debug(f'New page opened: {page.url}')\n\t\t\tif self.session is not None:\n\t\t\t\tself.session.current_page = page\n\n\t\tcontext.on('page', on_page)\n\n\tasync def get_session(self) -> BrowserSession:\n\t\t\"\"\"Lazy initialization of the browser and related components\"\"\"\n\t\tif self.session is None:\n\t\t\treturn await self._initialize_session()\n\t\treturn self.session\n\n\tasync def get_current_page(self) -> Page:\n\t\t\"\"\"Get the current page\"\"\"\n\t\tsession = await self.get_session()\n\t\treturn session.current_page\n\n\tasync def _create_context(self, browser: PlaywrightBrowser):\n\t\t\"\"\"Creates a new browser context with anti-detection measures and loads cookies if available.\"\"\"\n\t\tif self.browser.config.chrome_instance_path and len(browser.contexts) > 0:\n\t\t\t# Connect to existing Chrome instance instead of creating new one\n\t\t\tcontext = browser.contexts[0]\n\t\telse:\n\t\t\t# Original code for creating new context\n\t\t\tcontext = await browser.new_context(\n\t\t\t\tviewport=self.config.browser_window_size,\n\t\t\t\tno_viewport=False,\n\t\t\t\tuser_agent=(\n\t\t\t\t\t'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 '\n\t\t\t\t\t'(KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36'\n\t\t\t\t),\n\t\t\t\tjava_script_enabled=True,\n\t\t\t\tbypass_csp=self.config.disable_security,\n\t\t\t\tignore_https_errors=self.config.disable_security,\n\t\t\t\trecord_video_dir=self.config.save_recording_path,\n\t\t\t)\n\n\t\tif self.config.trace_path:\n\t\t\tawait context.tracing.start(screenshots=True, snapshots=True, sources=True)\n\n\t\t# Load cookies if they exist\n\t\tif self.config.cookies_file and os.path.exists(self.config.cookies_file):\n\t\t\twith open(self.config.cookies_file, 'r') as f:\n\t\t\t\tcookies = json.load(f)\n\t\t\t\tlogger.info(f'Loaded {len(cookies)} cookies from {self.config.cookies_file}')\n\t\t\t\tawait context.add_cookies(cookies)\n\n\t\t# Expose anti-detection scripts\n\t\tawait context.add_init_script(\n\t\t\t\"\"\"\n\t\t\t// Webdriver property\n\t\t\tObject.defineProperty(navigator, 'webdriver', {\n\t\t\t\tget: () => undefined\n\t\t\t});\n\n\t\t\t// Languages\n\t\t\tObject.defineProperty(navigator, 'languages', {\n\t\t\t\tget: () => ['en-US', 'en']\n\t\t\t});\n\n\t\t\t// Plugins\n\t\t\tObject.defineProperty(navigator, 'plugins', {\n\t\t\t\tget: () => [1, 2, 3, 4, 5]\n\t\t\t});\n\n\t\t\t// Chrome runtime\n\t\t\twindow.chrome = { runtime: {} };\n\n\t\t\t// Permissions\n\t\t\tconst originalQuery = window.navigator.permissions.query;\n\t\t\twindow.navigator.permissions.query = (parameters) => (\n\t\t\t\tparameters.name === 'notifications' ?\n\t\t\t\t\tPromise.resolve({ state: Notification.permission }) :\n\t\t\t\t\toriginalQuery(parameters)\n\t\t\t);\n\t\t\t\"\"\"\n\t\t)\n\n\t\treturn context\n\n\tasync def _wait_for_stable_network(self):\n\t\tpage = await self.get_current_page()\n\n\t\tpending_requests = set()\n\t\tlast_activity = asyncio.get_event_loop().time()\n\n\t\t# Define relevant resource types and content types\n\t\tRELEVANT_RESOURCE_TYPES = {\n\t\t\t'document',\n\t\t\t'stylesheet',\n\t\t\t'image',\n\t\t\t'font',\n\t\t\t'script',\n\t\t\t'iframe',\n\t\t}\n\n\t\tRELEVANT_CONTENT_TYPES = {\n\t\t\t'text/html',\n\t\t\t'text/css',\n\t\t\t'application/javascript',\n\t\t\t'image/',\n\t\t\t'font/',\n\t\t\t'application/json',\n\t\t}\n\n\t\t# Additional patterns to filter out\n\t\tIGNORED_URL_PATTERNS = {\n\t\t\t# Analytics and tracking\n\t\t\t'analytics',\n\t\t\t'tracking',\n\t\t\t'telemetry',\n\t\t\t'beacon',\n\t\t\t'metrics',\n\t\t\t# Ad-related\n\t\t\t'doubleclick',\n\t\t\t'adsystem',\n\t\t\t'adserver',\n\t\t\t'advertising',\n\t\t\t# Social media widgets\n\t\t\t'facebook.com/plugins',\n\t\t\t'platform.twitter',\n\t\t\t'linkedin.com/embed',\n\t\t\t# Live chat and support\n\t\t\t'livechat',\n\t\t\t'zendesk',\n\t\t\t'intercom',\n\t\t\t'crisp.chat',\n\t\t\t'hotjar',\n\t\t\t# Push notifications\n\t\t\t'push-notifications',\n\t\t\t'onesignal',\n\t\t\t'pushwoosh',\n\t\t\t# Background sync/heartbeat\n\t\t\t'heartbeat',\n\t\t\t'ping',\n\t\t\t'alive',\n\t\t\t# WebRTC and streaming\n\t\t\t'webrtc',\n\t\t\t'rtmp://',\n\t\t\t'wss://',\n\t\t\t# Common CDNs for dynamic content\n\t\t\t'cloudfront.net',\n\t\t\t'fastly.net',\n\t\t}\n\n\t\tasync def on_request(request):\n\t\t\t# Filter by resource type\n\t\t\tif request.resource_type not in RELEVANT_RESOURCE_TYPES:\n\t\t\t\treturn\n\n\t\t\t# Filter out streaming, websocket, and other real-time requests\n\t\t\tif request.resource_type in {\n\t\t\t\t'websocket',\n\t\t\t\t'media',\n\t\t\t\t'eventsource',\n\t\t\t\t'manifest',\n\t\t\t\t'other',\n\t\t\t}:\n\t\t\t\treturn\n\n\t\t\t# Filter out by URL patterns\n\t\t\turl = request.url.lower()\n\t\t\tif any(pattern in url for pattern in IGNORED_URL_PATTERNS):\n\t\t\t\treturn\n\n\t\t\t# Filter out data URLs and blob URLs\n\t\t\tif url.startswith(('data:', 'blob:')):\n\t\t\t\treturn\n\n\t\t\t# Filter out requests with certain headers\n\t\t\theaders = request.headers\n\t\t\tif headers.get('purpose') == 'prefetch' or headers.get('sec-fetch-dest') in [\n\t\t\t\t'video',\n\t\t\t\t'audio',\n\t\t\t]:\n\t\t\t\treturn\n\n\t\t\tnonlocal last_activity\n\t\t\tpending_requests.add(request)\n\t\t\tlast_activity = asyncio.get_event_loop().time()\n\t\t\t# logger.debug(f'Request started: {request.url} ({request.resource_type})')\n\n\t\tasync def on_response(response):\n\t\t\trequest = response.request\n\t\t\tif request not in pending_requests:\n\t\t\t\treturn\n\n\t\t\t# Filter by content type if available\n\t\t\tcontent_type = response.headers.get('content-type', '').lower()\n\n\t\t\t# Skip if content type indicates streaming or real-time data\n\t\t\tif any(\n\t\t\t\tt in content_type\n\t\t\t\tfor t in [\n\t\t\t\t\t'streaming',\n\t\t\t\t\t'video',\n\t\t\t\t\t'audio',\n\t\t\t\t\t'webm',\n\t\t\t\t\t'mp4',\n\t\t\t\t\t'event-stream',\n\t\t\t\t\t'websocket',\n\t\t\t\t\t'protobuf',\n\t\t\t\t]\n\t\t\t):\n\t\t\t\tpending_requests.remove(request)\n\t\t\t\treturn\n\n\t\t\t# Only process relevant content types\n\t\t\tif not any(ct in content_type for ct in RELEVANT_CONTENT_TYPES):\n\t\t\t\tpending_requests.remove(request)\n\t\t\t\treturn\n\n\t\t\t# Skip if response is too large (likely not essential for page load)\n\t\t\tcontent_length = response.headers.get('content-length')\n\t\t\tif content_length and int(content_length) > 5 * 1024 * 1024:  # 5MB\n\t\t\t\tpending_requests.remove(request)\n\t\t\t\treturn\n\n\t\t\tnonlocal last_activity\n\t\t\tpending_requests.remove(request)\n\t\t\tlast_activity = asyncio.get_event_loop().time()\n\t\t\t# logger.debug(f'Request resolved: {request.url} ({content_type})')\n\n\t\t# Attach event listeners\n\t\tpage.on('request', on_request)\n\t\tpage.on('response', on_response)\n\n\t\ttry:\n\t\t\t# Wait for idle time\n\t\t\tstart_time = asyncio.get_event_loop().time()\n\t\t\twhile True:\n\t\t\t\tawait asyncio.sleep(0.1)\n\t\t\t\tnow = asyncio.get_event_loop().time()\n\t\t\t\tif (\n\t\t\t\t\tlen(pending_requests) == 0\n\t\t\t\t\tand (now - last_activity) >= self.config.wait_for_network_idle_page_load_time\n\t\t\t\t):\n\t\t\t\t\tbreak\n\t\t\t\tif now - start_time > self.config.maximum_wait_page_load_time:\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\tf'Network timeout after {self.config.maximum_wait_page_load_time}s with {len(pending_requests)} '\n\t\t\t\t\t\tf'pending requests: {[r.url for r in pending_requests]}'\n\t\t\t\t\t)\n\t\t\t\t\tbreak\n\n\t\tfinally:\n\t\t\t# Clean up event listeners\n\t\t\tpage.remove_listener('request', on_request)\n\t\t\tpage.remove_listener('response', on_response)\n\n\t\tlogger.debug(\n\t\t\tf'Network stabilized for {self.config.wait_for_network_idle_page_load_time} seconds'\n\t\t)\n\n\tasync def _wait_for_page_and_frames_load(self, timeout_overwrite: float | None = None):\n\t\t\"\"\"\n\t\tEnsures page is fully loaded before continuing.\n\t\tWaits for either network to be idle or minimum WAIT_TIME, whichever is longer.\n\t\t\"\"\"\n\t\t# Start timing\n\t\tstart_time = time.time()\n\n\t\t# await asyncio.sleep(self.minimum_wait_page_load_time)\n\n\t\t# Wait for page load\n\t\ttry:\n\t\t\tawait self._wait_for_stable_network()\n\t\texcept Exception:\n\t\t\tlogger.warning('Page load failed, continuing...')\n\t\t\tpass\n\n\t\t# Calculate remaining time to meet minimum WAIT_TIME\n\t\telapsed = time.time() - start_time\n\t\tremaining = max((timeout_overwrite or self.config.minimum_wait_page_load_time) - elapsed, 0)\n\n\t\tlogger.debug(\n\t\t\tf'--Page loaded in {elapsed:.2f} seconds, waiting for additional {remaining:.2f} seconds'\n\t\t)\n\n\t\t# Sleep remaining time if needed\n\t\tif remaining > 0:\n\t\t\tawait asyncio.sleep(remaining)\n\n\tasync def navigate_to(self, url: str):\n\t\t\"\"\"Navigate to a URL\"\"\"\n\t\tpage = await self.get_current_page()\n\t\tawait page.goto(url)\n\t\tawait page.wait_for_load_state()\n\n\tasync def refresh_page(self):\n\t\t\"\"\"Refresh the current page\"\"\"\n\t\tpage = await self.get_current_page()\n\t\tawait page.reload()\n\t\tawait page.wait_for_load_state()\n\n\tasync def go_back(self):\n\t\t\"\"\"Navigate back in history\"\"\"\n\t\tpage = await self.get_current_page()\n\t\tawait page.go_back()\n\t\tawait page.wait_for_load_state()\n\n\tasync def go_forward(self):\n\t\t\"\"\"Navigate forward in history\"\"\"\n\t\tpage = await self.get_current_page()\n\t\tawait page.go_forward()\n\t\tawait page.wait_for_load_state()\n\n\tasync def close_current_tab(self):\n\t\t\"\"\"Close the current tab\"\"\"\n\t\tsession = await self.get_session()\n\t\tpage = session.current_page\n\t\tawait page.close()\n\n\t\t# Switch to the first available tab if any exist\n\t\tif session.context.pages:\n\t\t\tawait self.switch_to_tab(0)\n\n\t\t# otherwise the browser will be closed\n\n\tasync def get_page_html(self) -> str:\n\t\t\"\"\"Get the current page HTML content\"\"\"\n\t\tpage = await self.get_current_page()\n\t\treturn await page.content()\n\n\tasync def execute_javascript(self, script: str):\n\t\t\"\"\"Execute JavaScript code on the page\"\"\"\n\t\tpage = await self.get_current_page()\n\t\treturn await page.evaluate(script)\n\n\t@time_execution_sync('--get_state')  # This decorator might need to be updated to handle async\n\tasync def get_state(self, use_vision: bool = False) -> BrowserState:\n\t\t\"\"\"Get the current state of the browser\"\"\"\n\t\tawait self._wait_for_page_and_frames_load()\n\t\tsession = await self.get_session()\n\t\tsession.cached_state = await self._update_state(use_vision=use_vision)\n\n\t\t# Save cookies if a file is specified\n\t\tif self.config.cookies_file:\n\t\t\tasyncio.create_task(self.save_cookies())\n\n\t\treturn session.cached_state\n\n\tasync def _update_state(self, use_vision: bool = False) -> BrowserState:\n\t\t\"\"\"Update and return state.\"\"\"\n\t\tsession = await self.get_session()\n\n\t\t# Check if current page is still valid, if not switch to another available page\n\t\ttry:\n\t\t\tpage = await self.get_current_page()\n\t\t\t# Test if page is still accessible\n\t\t\tawait page.evaluate('1')\n\t\texcept Exception as e:\n\t\t\tlogger.debug(f'Current page is no longer accessible: {str(e)}')\n\t\t\t# Get all available pages\n\t\t\tpages = session.context.pages\n\t\t\tif pages:\n\t\t\t\tsession.current_page = pages[-1]\n\t\t\t\tpage = session.current_page\n\t\t\t\tlogger.debug(f'Switched to page: {await page.title()}')\n\t\t\telse:\n\t\t\t\traise BrowserError('No valid pages available')\n\n\t\ttry:\n\t\t\tawait self.remove_highlights()\n\t\t\tdom_service = DomService(page)\n\t\t\tcontent = await dom_service.get_clickable_elements()\n\n\t\t\tscreenshot_b64 = None\n\t\t\tif use_vision:\n\t\t\t\tscreenshot_b64 = await self.take_screenshot()\n\n\t\t\tself.current_state = BrowserState(\n\t\t\t\telement_tree=content.element_tree,\n\t\t\t\tselector_map=content.selector_map,\n\t\t\t\turl=page.url,\n\t\t\t\ttitle=await page.title(),\n\t\t\t\ttabs=await self.get_tabs_info(),\n\t\t\t\tscreenshot=screenshot_b64,\n\t\t\t)\n\n\t\t\treturn self.current_state\n\t\texcept Exception as e:\n\t\t\tlogger.error(f'Failed to update state: {str(e)}')\n\t\t\t# Return last known good state if available\n\t\t\tif hasattr(self, 'current_state'):\n\t\t\t\treturn self.current_state\n\t\t\traise\n\n\t# region - Browser Actions\n\n\tasync def take_screenshot(self, full_page: bool = False) -> str:\n\t\t\"\"\"\n\t\tReturns a base64 encoded screenshot of the current page.\n\t\t\"\"\"\n\t\tpage = await self.get_current_page()\n\n\t\tscreenshot = await page.screenshot(\n\t\t\tfull_page=full_page,\n\t\t\tanimations='disabled',\n\t\t)\n\n\t\tscreenshot_b64 = base64.b64encode(screenshot).decode('utf-8')\n\n\t\t# await self.remove_highlights()\n\n\t\treturn screenshot_b64\n\n\tasync def remove_highlights(self):\n\t\t\"\"\"\n\t\tRemoves all highlight overlays and labels created by the highlightElement function.\n\t\tHandles cases where the page might be closed or inaccessible.\n\t\t\"\"\"\n\t\ttry:\n\t\t\tpage = await self.get_current_page()\n\t\t\tawait page.evaluate(\n\t\t\t\t\"\"\"\n                try {\n                    // Remove the highlight container and all its contents\n                    const container = document.getElementById('playwright-highlight-container');\n                    if (container) {\n                        container.remove();\n                    }\n\n                    // Remove highlight attributes from elements\n                    const highlightedElements = document.querySelectorAll('[browser-user-highlight-id^=\"playwright-highlight-\"]');\n                    highlightedElements.forEach(el => {\n                        el.removeAttribute('browser-user-highlight-id');\n                    });\n                } catch (e) {\n                    console.error('Failed to remove highlights:', e);\n                }\n                \"\"\"\n\t\t\t)\n\t\texcept Exception as e:\n\t\t\tlogger.debug(f'Failed to remove highlights (this is usually ok): {str(e)}')\n\t\t\t# Don't raise the error since this is not critical functionality\n\t\t\tpass\n\n\t# endregion\n\n\t# region - User Actions\n\tdef _convert_simple_xpath_to_css_selector(self, xpath: str) -> str:\n\t\t\"\"\"Converts simple XPath expressions to CSS selectors.\"\"\"\n\t\tif not xpath:\n\t\t\treturn ''\n\n\t\t# Remove leading slash if present\n\t\txpath = xpath.lstrip('/')\n\n\t\t# Split into parts\n\t\tparts = xpath.split('/')\n\t\tcss_parts = []\n\n\t\tfor part in parts:\n\t\t\tif not part:\n\t\t\t\tcontinue\n\n\t\t\t# Handle index notation [n]\n\t\t\tif '[' in part:\n\t\t\t\tbase_part = part[: part.find('[')]\n\t\t\t\tindex_part = part[part.find('[') :]\n\n\t\t\t\t# Handle multiple indices\n\t\t\t\tindices = [i.strip('[]') for i in index_part.split(']')[:-1]]\n\n\t\t\t\tfor idx in indices:\n\t\t\t\t\ttry:\n\t\t\t\t\t\t# Handle numeric indices\n\t\t\t\t\t\tif idx.isdigit():\n\t\t\t\t\t\t\tindex = int(idx) - 1\n\t\t\t\t\t\t\tbase_part += f':nth-of-type({index+1})'\n\t\t\t\t\t\t# Handle last() function\n\t\t\t\t\t\telif idx == 'last()':\n\t\t\t\t\t\t\tbase_part += ':last-of-type'\n\t\t\t\t\t\t# Handle position() functions\n\t\t\t\t\t\telif 'position()' in idx:\n\t\t\t\t\t\t\tif '>1' in idx:\n\t\t\t\t\t\t\t\tbase_part += ':nth-of-type(n+2)'\n\t\t\t\t\texcept ValueError:\n\t\t\t\t\t\tcontinue\n\n\t\t\t\tcss_parts.append(base_part)\n\t\t\telse:\n\t\t\t\tcss_parts.append(part)\n\n\t\tbase_selector = ' > '.join(css_parts)\n\t\treturn base_selector\n\n\tdef _enhanced_css_selector_for_element(self, element: DOMElementNode) -> str:\n\t\t\"\"\"\n\t\tCreates a CSS selector for a DOM element, handling various edge cases and special characters.\n\n\t\tArgs:\n\t\t        element: The DOM element to create a selector for\n\n\t\tReturns:\n\t\t        A valid CSS selector string\n\t\t\"\"\"\n\t\ttry:\n\t\t\t# Get base selector from XPath\n\t\t\tcss_selector = self._convert_simple_xpath_to_css_selector(element.xpath)\n\n\t\t\t# Handle class attributes\n\t\t\tif 'class' in element.attributes and element.attributes['class']:\n\t\t\t\t# Define a regex pattern for valid class names in CSS\n\t\t\t\tvalid_class_name_pattern = re.compile(r'^[a-zA-Z_][a-zA-Z0-9_-]*$')\n\n\t\t\t\t# Iterate through the class attribute values\n\t\t\t\tclasses = element.attributes['class'].split()\n\t\t\t\tfor class_name in classes:\n\t\t\t\t\t# Skip empty class names\n\t\t\t\t\tif not class_name.strip():\n\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t# Check if the class name is valid\n\t\t\t\t\tif valid_class_name_pattern.match(class_name):\n\t\t\t\t\t\t# Append the valid class name to the CSS selector\n\t\t\t\t\t\tcss_selector += f'.{class_name}'\n\t\t\t\t\telse:\n\t\t\t\t\t\t# Skip invalid class names\n\t\t\t\t\t\tcontinue\n\n\t\t\t# Expanded set of safe attributes that are stable and useful for selection\n\t\t\tSAFE_ATTRIBUTES = {\n\t\t\t\t# Standard HTML attributes\n\t\t\t\t'id',\n\t\t\t\t'name',\n\t\t\t\t'type',\n\t\t\t\t'value',\n\t\t\t\t'placeholder',\n\t\t\t\t# Accessibility attributes\n\t\t\t\t'aria-label',\n\t\t\t\t'aria-labelledby',\n\t\t\t\t'aria-describedby',\n\t\t\t\t'role',\n\t\t\t\t# Common form attributes\n\t\t\t\t'for',\n\t\t\t\t'autocomplete',\n\t\t\t\t'required',\n\t\t\t\t'readonly',\n\t\t\t\t# Media attributes\n\t\t\t\t'alt',\n\t\t\t\t'title',\n\t\t\t\t'src',\n\t\t\t\t# Data attributes (if they're stable in your application)\n\t\t\t\t'data-testid',\n\t\t\t\t'data-id',\n\t\t\t\t'data-qa',\n\t\t\t\t'data-cy',\n\t\t\t\t# Custom stable attributes (add any application-specific ones)\n\t\t\t\t'href',\n\t\t\t\t'target',\n\t\t\t}\n\n\t\t\t# Handle other attributes\n\t\t\tfor attribute, value in element.attributes.items():\n\t\t\t\tif attribute == 'class':\n\t\t\t\t\tcontinue\n\n\t\t\t\t# Skip invalid attribute names\n\t\t\t\tif not attribute.strip():\n\t\t\t\t\tcontinue\n\n\t\t\t\tif attribute not in SAFE_ATTRIBUTES:\n\t\t\t\t\tcontinue\n\n\t\t\t\t# Escape special characters in attribute names\n\t\t\t\tsafe_attribute = attribute.replace(':', r'\\:')\n\n\t\t\t\t# Handle different value cases\n\t\t\t\tif value == '':\n\t\t\t\t\tcss_selector += f'[{safe_attribute}]'\n\t\t\t\telif any(char in value for char in '\"\\'<>`'):\n\t\t\t\t\t# Use contains for values with special characters\n\t\t\t\t\tsafe_value = value.replace('\"', '\\\\\"')\n\t\t\t\t\tcss_selector += f'[{safe_attribute}*=\"{safe_value}\"]'\n\t\t\t\telse:\n\t\t\t\t\tcss_selector += f'[{safe_attribute}=\"{value}\"]'\n\n\t\t\treturn css_selector\n\n\t\texcept Exception:\n\t\t\t# Fallback to a more basic selector if something goes wrong\n\t\t\ttag_name = element.tag_name or '*'\n\t\t\treturn f\"{tag_name}[highlight_index='{element.highlight_index}']\"\n\n\tasync def get_locate_element(self, element: DOMElementNode) -> ElementHandle | None:\n\t\tcurrent_frame = await self.get_current_page()\n\n\t\t# Start with the target element and collect all parents\n\t\tparents: list[DOMElementNode] = []\n\t\tcurrent = element\n\t\twhile current.parent is not None:\n\t\t\tparent = current.parent\n\t\t\tparents.append(parent)\n\t\t\tcurrent = parent\n\t\t\tif parent.tag_name == 'iframe':\n\t\t\t\tbreak\n\n\t\t# There can be only one iframe parent (by design of the loop above)\n\t\tiframe_parent = [item for item in parents if item.tag_name == 'iframe']\n\t\tif iframe_parent:\n\t\t\tparent = iframe_parent[0]\n\t\t\tcss_selector = self._enhanced_css_selector_for_element(parent)\n\t\t\tcurrent_frame = current_frame.frame_locator(css_selector)\n\n\t\tcss_selector = self._enhanced_css_selector_for_element(element)\n\n\t\ttry:\n\t\t\tif isinstance(current_frame, FrameLocator):\n\t\t\t\treturn await current_frame.locator(css_selector).element_handle()\n\t\t\telse:\n\t\t\t\t# Try to scroll into view if hidden\n\t\t\t\telement_handle = await current_frame.query_selector(css_selector)\n\t\t\t\tif element_handle:\n\t\t\t\t\tawait element_handle.scroll_into_view_if_needed()\n\t\t\t\t\treturn element_handle\n\t\texcept Exception as e:\n\t\t\tlogger.error(f'Failed to locate element: {str(e)}')\n\t\t\treturn None\n\n\tasync def _input_text_element_node(self, element_node: DOMElementNode, text: str):\n\t\ttry:\n\t\t\tpage = await self.get_current_page()\n\t\t\telement = await self.get_locate_element(element_node)\n\n\t\t\tif element is None:\n\t\t\t\traise Exception(f'Element: {repr(element_node)} not found')\n\n\t\t\tawait element.scroll_into_view_if_needed(timeout=2500)\n\t\t\tawait element.fill('')\n\t\t\tawait element.type(text)\n\t\t\tawait page.wait_for_load_state()\n\n\t\texcept Exception as e:\n\t\t\traise Exception(\n\t\t\t\tf'Failed to input text into element: {repr(element_node)}. Error: {str(e)}'\n\t\t\t)\n\n\tasync def _click_element_node(self, element_node: DOMElementNode):\n\t\t\"\"\"\n\t\tOptimized method to click an element using xpath.\n\t\t\"\"\"\n\t\tpage = await self.get_current_page()\n\n\t\ttry:\n\t\t\telement = await self.get_locate_element(element_node)\n\n\t\t\tif element is None:\n\t\t\t\traise Exception(f'Element: {repr(element_node)} not found')\n\n\t\t\t# await element.scroll_into_view_if_needed()\n\n\t\t\ttry:\n\t\t\t\tawait element.click(timeout=1500)\n\t\t\t\tawait page.wait_for_load_state()\n\t\t\texcept Exception:\n\t\t\t\ttry:\n\t\t\t\t\tawait page.evaluate('(el) => el.click()', element)\n\t\t\t\t\tawait page.wait_for_load_state()\n\t\t\t\texcept Exception as e:\n\t\t\t\t\traise Exception(f'Failed to click element: {str(e)}')\n\n\t\texcept Exception as e:\n\t\t\traise Exception(f'Failed to click element: {repr(element_node)}. Error: {str(e)}')\n\n\tasync def get_tabs_info(self) -> list[TabInfo]:\n\t\t\"\"\"Get information about all tabs\"\"\"\n\t\tsession = await self.get_session()\n\n\t\ttabs_info = []\n\t\tfor page_id, page in enumerate(session.context.pages):\n\t\t\ttab_info = TabInfo(page_id=page_id, url=page.url, title=await page.title())\n\t\t\ttabs_info.append(tab_info)\n\n\t\treturn tabs_info\n\n\tasync def switch_to_tab(self, page_id: int) -> None:\n\t\t\"\"\"Switch to a specific tab by its page_id\n\n\t\t@You can also use negative indices to switch to tabs from the end (Pure pythonic way)\n\t\t\"\"\"\n\t\tsession = await self.get_session()\n\t\tpages = session.context.pages\n\n\t\tif page_id >= len(pages):\n\t\t\traise BrowserError(f'No tab found with page_id: {page_id}')\n\n\t\tpage = pages[page_id]\n\t\tsession.current_page = page\n\n\t\tawait page.bring_to_front()\n\t\tawait page.wait_for_load_state()\n\n\tasync def create_new_tab(self, url: str | None = None) -> None:\n\t\t\"\"\"Create a new tab and optionally navigate to a URL\"\"\"\n\t\tsession = await self.get_session()\n\t\tnew_page = await session.context.new_page()\n\t\tsession.current_page = new_page\n\n\t\tawait new_page.wait_for_load_state()\n\n\t\tpage = await self.get_current_page()\n\n\t\tif url:\n\t\t\tawait page.goto(url)\n\t\t\tawait self._wait_for_page_and_frames_load(timeout_overwrite=1)\n\n\t# endregion\n\n\t# region - Helper methods for easier access to the DOM\n\tasync def get_selector_map(self) -> SelectorMap:\n\t\tsession = await self.get_session()\n\t\treturn session.cached_state.selector_map\n\n\tasync def get_element_by_index(self, index: int) -> ElementHandle | None:\n\t\tselector_map = await self.get_selector_map()\n\t\treturn await self.get_locate_element(selector_map[index])\n\n\tasync def get_dom_element_by_index(self, index: int) -> DOMElementNode | None:\n\t\tselector_map = await self.get_selector_map()\n\t\treturn selector_map[index]\n\n\tasync def save_cookies(self):\n\t\t\"\"\"Save current cookies to file\"\"\"\n\t\tif self.session and self.session.context and self.config.cookies_file:\n\t\t\ttry:\n\t\t\t\tcookies = await self.session.context.cookies()\n\t\t\t\tlogger.info(f'Saving {len(cookies)} cookies to {self.config.cookies_file}')\n\n\t\t\t\t# Check if the path is a directory and create it if necessary\n\t\t\t\tdirname = os.path.dirname(self.config.cookies_file)\n\t\t\t\tif dirname:\n\t\t\t\t\tos.makedirs(dirname, exist_ok=True)\n\n\t\t\t\twith open(self.config.cookies_file, 'w') as f:\n\t\t\t\t\tjson.dump(cookies, f)\n\t\t\texcept Exception as e:\n\t\t\t\tlogger.warning(f'Failed to save cookies: {str(e)}')\n\n\tasync def is_file_uploader(\n\t\tself, element_node: DOMElementNode, max_depth: int = 3, current_depth: int = 0\n\t) -> bool:\n\t\t\"\"\"Check if element or its children are file uploaders\"\"\"\n\t\tif current_depth > max_depth:\n\t\t\treturn False\n\n\t\t# Check current element\n\t\tis_uploader = False\n\n\t\tif not isinstance(element_node, DOMElementNode):\n\t\t\treturn False\n\n\t\t# Check for file input attributes\n\t\tif element_node.tag_name == 'input':\n\t\t\tis_uploader = (\n\t\t\t\telement_node.attributes.get('type') == 'file'\n\t\t\t\tor element_node.attributes.get('accept') is not None\n\t\t\t)\n\n\t\tif is_uploader:\n\t\t\treturn True\n\n\t\t# Recursively check children\n\t\tif element_node.children and current_depth < max_depth:\n\t\t\tfor child in element_node.children:\n\t\t\t\tif isinstance(child, DOMElementNode):\n\t\t\t\t\tif await self.is_file_uploader(child, max_depth, current_depth + 1):\n\t\t\t\t\t\treturn True\n\n\t\treturn False\n",
    "isBinary": "false"
  },
  "examples/save_trace.py": {
    "code": "import os\nimport sys\n\nfrom langchain_openai import ChatOpenAI\n\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\nimport asyncio\n\nfrom browser_use.agent.service import Agent\nfrom browser_use.browser.browser import Browser\nfrom browser_use.browser.context import BrowserContextConfig\n\nllm = ChatOpenAI(model='gpt-4o', temperature=0.0)\n\n\nasync def main():\n\tbrowser = Browser()\n\n\tasync with await browser.new_context(\n\t\tconfig=BrowserContextConfig(trace_path='./tmp/traces/')\n\t) as context:\n\t\tagent = Agent(\n\t\t\ttask='Go to hackernews, then go to apple.com and return all titles of open tabs',\n\t\t\tllm=llm,\n\t\t\tbrowser_context=context,\n\t\t)\n\t\tawait agent.run()\n\n\tawait browser.close()\n\n\nasyncio.run(main())\n",
    "isBinary": "false"
  },
  "browser_use/agent/message_manager/tests.py": {
    "isBinary": "false",
    "code": "import pytest\nfrom langchain_anthropic import ChatAnthropic\nfrom langchain_core.messages import AIMessage, HumanMessage, SystemMessage\nfrom langchain_openai import AzureChatOpenAI, ChatOpenAI\n\nfrom browser_use.agent.message_manager.service import MessageManager\nfrom browser_use.agent.prompts import SystemPrompt\nfrom browser_use.agent.views import ActionResult\nfrom browser_use.browser.views import BrowserState, TabInfo\nfrom browser_use.dom.views import DOMElementNode, DOMTextNode\n\n\n@pytest.fixture(\n\tparams=[\n\t\tChatOpenAI(model='gpt-4o-mini'),\n\t\tAzureChatOpenAI(model='gpt-4o', api_version='2024-02-15-preview'),\n\t\tChatAnthropic(\n\t\t\tmodel_name='claude-3-5-sonnet-20240620', timeout=100, temperature=0.0, stop=None\n\t\t),\n\t],\n\tids=['gpt-4o-mini', 'gpt-4o', 'claude-3-5-sonnet'],\n)\ndef message_manager(request: pytest.FixtureRequest):\n\tllm = request.param\n\ttask = 'Test task'\n\taction_descriptions = 'Test actions'\n\treturn MessageManager(\n\t\tllm=llm,\n\t\ttask=task,\n\t\taction_descriptions=action_descriptions,\n\t\tsystem_prompt_class=SystemPrompt,\n\t\tmax_input_tokens=1000,\n\t\testimated_tokens_per_character=3,\n\t\timage_tokens=800,\n\t)\n\n\ndef test_initial_messages(message_manager: MessageManager):\n\t\"\"\"Test that message manager initializes with system and task messages\"\"\"\n\tmessages = message_manager.get_messages()\n\tassert len(messages) == 2\n\tassert isinstance(messages[0], SystemMessage)\n\tassert isinstance(messages[1], HumanMessage)\n\tassert 'Test task' in messages[1].content\n\n\ndef test_add_state_message(message_manager: MessageManager):\n\t\"\"\"Test adding browser state message\"\"\"\n\tstate = BrowserState(\n\t\turl='https://test.com',\n\t\ttitle='Test Page',\n\t\telement_tree=DOMElementNode(\n\t\t\ttag_name='div',\n\t\t\tattributes={},\n\t\t\tchildren=[],\n\t\t\tis_visible=True,\n\t\t\tparent=None,\n\t\t\txpath='//div',\n\t\t),\n\t\tselector_map={},\n\t\ttabs=[TabInfo(page_id=1, url='https://test.com', title='Test Page')],\n\t)\n\tmessage_manager.add_state_message(state)\n\n\tmessages = message_manager.get_messages()\n\tassert len(messages) == 3\n\tassert isinstance(messages[2], HumanMessage)\n\tassert 'https://test.com' in messages[2].content\n\n\ndef test_add_state_with_memory_result(message_manager: MessageManager):\n\t\"\"\"Test adding state with result that should be included in memory\"\"\"\n\tstate = BrowserState(\n\t\turl='https://test.com',\n\t\ttitle='Test Page',\n\t\telement_tree=DOMElementNode(\n\t\t\ttag_name='div',\n\t\t\tattributes={},\n\t\t\tchildren=[],\n\t\t\tis_visible=True,\n\t\t\tparent=None,\n\t\t\txpath='//div',\n\t\t),\n\t\tselector_map={},\n\t\ttabs=[TabInfo(page_id=1, url='https://test.com', title='Test Page')],\n\t)\n\tresult = ActionResult(extracted_content='Important content', include_in_memory=True)\n\n\tmessage_manager.add_state_message(state, result)\n\tmessages = message_manager.get_messages()\n\n\t# Should have system, task, extracted content, and state messages\n\tassert len(messages) == 4\n\tassert 'Important content' in messages[2].content\n\tassert isinstance(messages[2], HumanMessage)\n\tassert isinstance(messages[3], HumanMessage)\n\tassert 'Important content' not in messages[3].content\n\n\ndef test_add_state_with_non_memory_result(message_manager: MessageManager):\n\t\"\"\"Test adding state with result that should not be included in memory\"\"\"\n\tstate = BrowserState(\n\t\turl='https://test.com',\n\t\ttitle='Test Page',\n\t\telement_tree=DOMElementNode(\n\t\t\ttag_name='div',\n\t\t\tattributes={},\n\t\t\tchildren=[],\n\t\t\tis_visible=True,\n\t\t\tparent=None,\n\t\t\txpath='//div',\n\t\t),\n\t\tselector_map={},\n\t\ttabs=[TabInfo(page_id=1, url='https://test.com', title='Test Page')],\n\t)\n\tresult = ActionResult(extracted_content='Temporary content', include_in_memory=False)\n\n\tmessage_manager.add_state_message(state, result)\n\tmessages = message_manager.get_messages()\n\n\t# Should have system, task, and combined state+result message\n\tassert len(messages) == 3\n\tassert 'Temporary content' in messages[2].content\n\tassert isinstance(messages[2], HumanMessage)\n\n\n@pytest.mark.skip('not sure how to fix this')\n@pytest.mark.parametrize('max_tokens', [100000, 10000, 5000])\ndef test_token_overflow_handling_with_real_flow(message_manager: MessageManager, max_tokens):\n\t\"\"\"Test handling of token overflow in a realistic message flow\"\"\"\n\t# Set more realistic token limit\n\tmessage_manager.max_input_tokens = max_tokens\n\n\t# Create a long sequence of interactions\n\tfor i in range(200):  # Simulate 40 steps of interaction\n\t\t# Create state with varying content length\n\t\tstate = BrowserState(\n\t\t\turl=f'https://test{i}.com',\n\t\t\ttitle=f'Test Page {i}',\n\t\t\telement_tree=DOMElementNode(\n\t\t\t\ttag_name='div',\n\t\t\t\tattributes={},\n\t\t\t\tchildren=[\n\t\t\t\t\tDOMTextNode(\n\t\t\t\t\t\ttext=f'Content {j} ' * (10 + i),  # Increasing content length\n\t\t\t\t\t\tis_visible=True,\n\t\t\t\t\t\tparent=None,\n\t\t\t\t\t)\n\t\t\t\t\tfor j in range(5)  # Multiple DOM items\n\t\t\t\t],\n\t\t\t\tis_visible=True,\n\t\t\t\tparent=None,\n\t\t\t\txpath='//div',\n\t\t\t),\n\t\t\tselector_map={j: f'//div[{j}]' for j in range(5)},\n\t\t\ttabs=[TabInfo(page_id=1, url=f'https://test{i}.com', title=f'Test Page {i}')],\n\t\t)\n\n\t\t# Alternate between different types of results\n\t\tresult = None\n\t\tif i % 2 == 0:  # Every other iteration\n\t\t\tresult = ActionResult(\n\t\t\t\textracted_content=f'Important content from step {i}' * 5,\n\t\t\t\tinclude_in_memory=i % 4 == 0,  # Include in memory every 4th message\n\t\t\t)\n\n\t\t# Add state message\n\t\tmessage_manager.add_state_message(state, result)\n\n\t\ttry:\n\t\t\tmessages = message_manager.get_messages()\n\t\texcept ValueError as e:\n\t\t\tif 'Max token limit reached - history is too long' in str(e):\n\t\t\t\treturn  # If error occurs, end the test\n\t\t\telse:\n\t\t\t\traise e\n\n\t\tassert message_manager.history.total_tokens <= message_manager.max_input_tokens + 100\n\n\t\tlast_msg = messages[-1]\n\t\tassert isinstance(last_msg, HumanMessage)\n\n\t\tif i % 4 == 0:\n\t\t\tassert isinstance(message_manager.history.messages[-2].message, HumanMessage)\n\t\tif i % 2 == 0 and not i % 4 == 0:\n\t\t\tif isinstance(last_msg.content, list):\n\t\t\t\tassert 'Current url: https://test' in last_msg.content[0]['text']\n\t\t\telse:\n\t\t\t\tassert 'Current url: https://test' in last_msg.content\n\n\t\t# Add model output every time\n\t\tfrom browser_use.agent.views import AgentBrain, AgentOutput\n\t\tfrom browser_use.controller.registry.views import ActionModel\n\n\t\toutput = AgentOutput(\n\t\t\tcurrent_state=AgentBrain(\n\t\t\t\tevaluation_previous_goal=f'Success in step {i}',\n\t\t\t\tmemory=f'Memory from step {i}',\n\t\t\t\tnext_goal=f'Goal for step {i+1}',\n\t\t\t),\n\t\t\taction=[ActionModel()],\n\t\t)\n\t\tmessage_manager._remove_last_state_message()\n\t\tmessage_manager.add_model_output(output)\n\n\t\t# Get messages and verify after each addition\n\t\tmessages = [m.message for m in message_manager.history.messages]\n\n\t\t# Verify token limit is respected\n\n\t\t# Verify essential messages are preserved\n\t\tassert isinstance(messages[0], SystemMessage)  # System prompt always first\n\t\tassert isinstance(messages[1], HumanMessage)  # Task always second\n\t\tassert 'Test task' in messages[1].content\n\n\t\t# Verify structure of latest messages\n\t\tassert isinstance(messages[-1], AIMessage)  # Last message should be model output\n\t\tassert f'step {i}' in messages[-1].content  # Should contain current step info\n\n\t\t# Log token usage for debugging\n\t\ttoken_usage = message_manager.history.total_tokens\n\t\ttoken_limit = message_manager.max_input_tokens\n\t\t# print(f'Step {i}: Using {token_usage}/{token_limit} tokens')\n\n\t\t# go through all messages and verify that the token count and total tokens is correct\n\t\ttotal_tokens = 0\n\t\treal_tokens = []\n\t\tstored_tokens = []\n\t\tfor msg in message_manager.history.messages:\n\t\t\ttotal_tokens += msg.metadata.input_tokens\n\t\t\tstored_tokens.append(msg.metadata.input_tokens)\n\t\t\treal_tokens.append(message_manager._count_tokens(msg.message))\n\t\tassert total_tokens == sum(real_tokens)\n\t\tassert stored_tokens == real_tokens\n\t\tassert message_manager.history.total_tokens == total_tokens\n\n\n# pytest -s browser_use/agent/message_manager/tests.py\n"
  },
  "browser_use/dom/views.py": {
    "code": "from dataclasses import dataclass\nfrom functools import cached_property\nfrom typing import TYPE_CHECKING, Dict, List, Optional\n\nfrom browser_use.dom.history_tree_processor.view import HashedDomElement\n\n# Avoid circular import issues\nif TYPE_CHECKING:\n\tfrom .views import DOMElementNode\n\n\n@dataclass(frozen=False)\nclass DOMBaseNode:\n\tis_visible: bool\n\t# Use None as default and set parent later to avoid circular reference issues\n\tparent: Optional['DOMElementNode']\n\n\n@dataclass(frozen=False)\nclass DOMTextNode(DOMBaseNode):\n\ttext: str\n\ttype: str = 'TEXT_NODE'\n\n\tdef has_parent_with_highlight_index(self) -> bool:\n\t\tcurrent = self.parent\n\t\twhile current is not None:\n\t\t\tif current.highlight_index is not None:\n\t\t\t\treturn True\n\t\t\tcurrent = current.parent\n\t\treturn False\n\n\n@dataclass(frozen=False)\nclass DOMElementNode(DOMBaseNode):\n\t\"\"\"\n\txpath: the xpath of the element from the last root node (shadow root or iframe OR document if no shadow root or iframe).\n\tTo properly reference the element we need to recursively switch the root node until we find the element (work you way up the tree with `.parent`)\n\t\"\"\"\n\n\ttag_name: str\n\txpath: str\n\tattributes: Dict[str, str]\n\tchildren: List[DOMBaseNode]\n\tis_interactive: bool = False\n\tis_top_element: bool = False\n\tshadow_root: bool = False\n\thighlight_index: Optional[int] = None\n\n\tdef __repr__(self) -> str:\n\t\ttag_str = f'<{self.tag_name}'\n\n\t\t# Add attributes\n\t\tfor key, value in self.attributes.items():\n\t\t\ttag_str += f' {key}=\"{value}\"'\n\t\ttag_str += '>'\n\n\t\t# Add extra info\n\t\textras = []\n\t\tif self.is_interactive:\n\t\t\textras.append('interactive')\n\t\tif self.is_top_element:\n\t\t\textras.append('top')\n\t\tif self.shadow_root:\n\t\t\textras.append('shadow-root')\n\t\tif self.highlight_index is not None:\n\t\t\textras.append(f'highlight:{self.highlight_index}')\n\n\t\tif extras:\n\t\t\ttag_str += f' [{\", \".join(extras)}]'\n\n\t\treturn tag_str\n\n\t@cached_property\n\tdef hash(self) -> HashedDomElement:\n\t\tfrom browser_use.dom.history_tree_processor.service import (\n\t\t\tHistoryTreeProcessor,\n\t\t)\n\n\t\treturn HistoryTreeProcessor._hash_dom_element(self)\n\n\tdef get_all_text_till_next_clickable_element(self) -> str:\n\t\ttext_parts = []\n\n\t\tdef collect_text(node: DOMBaseNode) -> None:\n\t\t\t# Skip this branch if we hit a highlighted element (except for the current node)\n\t\t\tif (\n\t\t\t\tisinstance(node, DOMElementNode)\n\t\t\t\tand node != self\n\t\t\t\tand node.highlight_index is not None\n\t\t\t):\n\t\t\t\treturn\n\n\t\t\tif isinstance(node, DOMTextNode):\n\t\t\t\ttext_parts.append(node.text)\n\t\t\telif isinstance(node, DOMElementNode):\n\t\t\t\tfor child in node.children:\n\t\t\t\t\tcollect_text(child)\n\n\t\tcollect_text(self)\n\t\treturn '\\n'.join(text_parts).strip()\n\n\tdef clickable_elements_to_string(self, include_attributes: list[str] = []) -> str:\n\t\t\"\"\"Convert the processed DOM content to HTML.\"\"\"\n\t\tformatted_text = []\n\n\t\tdef process_node(node: DOMBaseNode, depth: int) -> None:\n\t\t\tif isinstance(node, DOMElementNode):\n\t\t\t\t# Add element with highlight_index\n\t\t\t\tif node.highlight_index is not None:\n\t\t\t\t\tattributes_str = ''\n\t\t\t\t\tif include_attributes:\n\t\t\t\t\t\tattributes_str = ' ' + ' '.join(\n\t\t\t\t\t\t\tf'{key}=\"{value}\"'\n\t\t\t\t\t\t\tfor key, value in node.attributes.items()\n\t\t\t\t\t\t\tif key in include_attributes\n\t\t\t\t\t\t)\n\t\t\t\t\tformatted_text.append(\n\t\t\t\t\t\tf'{node.highlight_index}[:]<{node.tag_name}{attributes_str}>{node.get_all_text_till_next_clickable_element()}</{node.tag_name}>'\n\t\t\t\t\t)\n\n\t\t\t\t# Process children regardless\n\t\t\t\tfor child in node.children:\n\t\t\t\t\tprocess_node(child, depth + 1)\n\n\t\t\telif isinstance(node, DOMTextNode):\n\t\t\t\t# Add text only if it doesn't have a highlighted parent\n\t\t\t\tif not node.has_parent_with_highlight_index():\n\t\t\t\t\tformatted_text.append(f'_[:]{node.text}')\n\n\t\tprocess_node(self, 0)\n\t\treturn '\\n'.join(formatted_text)\n\n\tdef get_file_upload_element(self, check_siblings: bool = True) -> Optional['DOMElementNode']:\n\t\t# Check if current element is a file input\n\t\tif self.tag_name == 'input' and self.attributes.get('type') == 'file':\n\t\t\treturn self\n\n\t\t# Check children\n\t\tfor child in self.children:\n\t\t\tif isinstance(child, DOMElementNode):\n\t\t\t\tresult = child.get_file_upload_element(check_siblings=False)\n\t\t\t\tif result:\n\t\t\t\t\treturn result\n\n\t\t# Check siblings only for the initial call\n\t\tif check_siblings and self.parent:\n\t\t\tfor sibling in self.parent.children:\n\t\t\t\tif sibling is not self and isinstance(sibling, DOMElementNode):\n\t\t\t\t\tresult = sibling.get_file_upload_element(check_siblings=False)\n\t\t\t\t\tif result:\n\t\t\t\t\t\treturn result\n\n\t\treturn None\n\n\nclass ElementTreeSerializer:\n\t@staticmethod\n\tdef serialize_clickable_elements(element_tree: DOMElementNode) -> str:\n\t\treturn element_tree.clickable_elements_to_string()\n\n\t@staticmethod\n\tdef dom_element_node_to_json(element_tree: DOMElementNode) -> dict:\n\t\tdef node_to_dict(node: DOMBaseNode) -> dict:\n\t\t\tif isinstance(node, DOMTextNode):\n\t\t\t\treturn {'type': 'text', 'text': node.text}\n\t\t\telif isinstance(node, DOMElementNode):\n\t\t\t\treturn {\n\t\t\t\t\t'type': 'element',\n\t\t\t\t\t'tag_name': node.tag_name,\n\t\t\t\t\t'attributes': node.attributes,\n\t\t\t\t\t'highlight_index': node.highlight_index,\n\t\t\t\t\t'children': [node_to_dict(child) for child in node.children],\n\t\t\t\t}\n\t\t\treturn {}\n\n\t\treturn node_to_dict(element_tree)\n\n\nSelectorMap = dict[int, DOMElementNode]\n\n\n@dataclass\nclass DOMState:\n\telement_tree: DOMElementNode\n\tselector_map: SelectorMap\n",
    "isBinary": "false"
  },
  "browser_use/agent/views.py": {
    "isBinary": "false",
    "code": "from __future__ import annotations\n\nimport json\nimport traceback\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Any, Dict, Optional, Type\n\nfrom openai import RateLimitError\nfrom pydantic import BaseModel, ConfigDict, Field, ValidationError, create_model\n\nfrom browser_use.browser.views import BrowserStateHistory\nfrom browser_use.controller.registry.views import ActionModel\nfrom browser_use.dom.history_tree_processor.service import (\n\tDOMElementNode,\n\tDOMHistoryElement,\n\tHistoryTreeProcessor,\n)\nfrom browser_use.dom.views import SelectorMap\n\n\n@dataclass\nclass AgentStepInfo:\n\tstep_number: int\n\tmax_steps: int\n\n\nclass ActionResult(BaseModel):\n\t\"\"\"Result of executing an action\"\"\"\n\n\tis_done: Optional[bool] = False\n\textracted_content: Optional[str] = None\n\terror: Optional[str] = None\n\tinclude_in_memory: bool = False  # whether to include in past messages as context or not\n\n\nclass AgentBrain(BaseModel):\n\t\"\"\"Current state of the agent\"\"\"\n\n\tevaluation_previous_goal: str\n\tmemory: str\n\tnext_goal: str\n\n\nclass AgentOutput(BaseModel):\n\t\"\"\"Output model for agent\n\n\t@dev note: this model is extended with custom actions in AgentService. You can also use some fields that are not in this model as provided by the linter, as long as they are registered in the DynamicActions model.\n\t\"\"\"\n\n\tmodel_config = ConfigDict(arbitrary_types_allowed=True)\n\n\tcurrent_state: AgentBrain\n\taction: list[ActionModel]\n\n\t@staticmethod\n\tdef type_with_custom_actions(custom_actions: Type[ActionModel]) -> Type['AgentOutput']:\n\t\t\"\"\"Extend actions with custom actions\"\"\"\n\t\treturn create_model(\n\t\t\t'AgentOutput',\n\t\t\t__base__=AgentOutput,\n\t\t\taction=(list[custom_actions], Field(...)),  # Properly annotated field with no default\n\t\t\t__module__=AgentOutput.__module__,\n\t\t)\n\n\nclass AgentHistory(BaseModel):\n\t\"\"\"History item for agent actions\"\"\"\n\n\tmodel_output: AgentOutput | None\n\tresult: list[ActionResult]\n\tstate: BrowserStateHistory\n\n\tmodel_config = ConfigDict(arbitrary_types_allowed=True, protected_namespaces=())\n\n\t@staticmethod\n\tdef get_interacted_element(\n\t\tmodel_output: AgentOutput, selector_map: SelectorMap\n\t) -> list[DOMHistoryElement | None]:\n\t\telements = []\n\t\tfor action in model_output.action:\n\t\t\tindex = action.get_index()\n\t\t\tif index and index in selector_map:\n\t\t\t\tel: DOMElementNode = selector_map[index]\n\t\t\t\telements.append(HistoryTreeProcessor.convert_dom_element_to_history_element(el))\n\t\t\telse:\n\t\t\t\telements.append(None)\n\t\treturn elements\n\n\tdef model_dump(self, **kwargs) -> Dict[str, Any]:\n\t\t\"\"\"Custom serialization handling circular references\"\"\"\n\n\t\t# Handle action serialization\n\t\tmodel_output_dump = None\n\t\tif self.model_output:\n\t\t\taction_dump = [\n\t\t\t\taction.model_dump(exclude_none=True) for action in self.model_output.action\n\t\t\t]\n\t\t\tmodel_output_dump = {\n\t\t\t\t'current_state': self.model_output.current_state.model_dump(),\n\t\t\t\t'action': action_dump,  # This preserves the actual action data\n\t\t\t}\n\n\t\treturn {\n\t\t\t'model_output': model_output_dump,\n\t\t\t'result': [r.model_dump(exclude_none=True) for r in self.result],\n\t\t\t'state': self.state.to_dict(),\n\t\t}\n\n\nclass AgentHistoryList(BaseModel):\n\t\"\"\"List of agent history items\"\"\"\n\n\thistory: list[AgentHistory]\n\n\tdef __str__(self) -> str:\n\t\t\"\"\"Representation of the AgentHistoryList object\"\"\"\n\t\treturn f'AgentHistoryList(all_results={self.action_results()}, all_model_outputs={self.model_actions()})'\n\n\tdef __repr__(self) -> str:\n\t\t\"\"\"Representation of the AgentHistoryList object\"\"\"\n\t\treturn self.__str__()\n\n\tdef save_to_file(self, filepath: str | Path) -> None:\n\t\t\"\"\"Save history to JSON file with proper serialization\"\"\"\n\t\ttry:\n\t\t\tPath(filepath).parent.mkdir(parents=True, exist_ok=True)\n\t\t\tdata = self.model_dump()\n\t\t\twith open(filepath, 'w', encoding='utf-8') as f:\n\t\t\t\tjson.dump(data, f, indent=2)\n\t\texcept Exception as e:\n\t\t\traise e\n\n\tdef model_dump(self, **kwargs) -> Dict[str, Any]:\n\t\t\"\"\"Custom serialization that properly uses AgentHistory's model_dump\"\"\"\n\t\treturn {\n\t\t\t'history': [h.model_dump(**kwargs) for h in self.history],\n\t\t}\n\n\t@classmethod\n\tdef load_from_file(\n\t\tcls, filepath: str | Path, output_model: Type[AgentOutput]\n\t) -> 'AgentHistoryList':\n\t\t\"\"\"Load history from JSON file\"\"\"\n\t\twith open(filepath, 'r', encoding='utf-8') as f:\n\t\t\tdata = json.load(f)\n\t\t# loop through history and validate output_model actions to enrich with custom actions\n\t\tfor h in data['history']:\n\t\t\tif h['model_output']:\n\t\t\t\tif isinstance(h['model_output'], dict):\n\t\t\t\t\th['model_output'] = output_model.model_validate(h['model_output'])\n\t\t\t\telse:\n\t\t\t\t\th['model_output'] = None\n\t\t\tif 'interacted_element' not in h['state']:\n\t\t\t\th['state']['interacted_element'] = None\n\t\thistory = cls.model_validate(data)\n\t\treturn history\n\n\tdef last_action(self) -> None | dict:\n\t\t\"\"\"Last action in history\"\"\"\n\t\tif self.history and self.history[-1].model_output:\n\t\t\treturn self.history[-1].model_output.action[-1].model_dump(exclude_none=True)\n\t\treturn None\n\n\tdef errors(self) -> list[str]:\n\t\t\"\"\"Get all errors from history\"\"\"\n\t\terrors = []\n\t\tfor h in self.history:\n\t\t\terrors.extend([r.error for r in h.result if r.error])\n\t\treturn errors\n\n\tdef final_result(self) -> None | str:\n\t\t\"\"\"Final result from history\"\"\"\n\t\tif self.history and self.history[-1].result[-1].extracted_content:\n\t\t\treturn self.history[-1].result[-1].extracted_content\n\t\treturn None\n\n\tdef is_done(self) -> bool:\n\t\t\"\"\"Check if the agent is done\"\"\"\n\t\tif (\n\t\t\tself.history\n\t\t\tand len(self.history[-1].result) > 0\n\t\t\tand self.history[-1].result[-1].is_done\n\t\t):\n\t\t\treturn self.history[-1].result[-1].is_done\n\t\treturn False\n\n\tdef has_errors(self) -> bool:\n\t\t\"\"\"Check if the agent has any errors\"\"\"\n\t\treturn len(self.errors()) > 0\n\n\tdef urls(self) -> list[str]:\n\t\t\"\"\"Get all unique URLs from history\"\"\"\n\t\treturn [h.state.url for h in self.history if h.state.url]\n\n\tdef screenshots(self) -> list[str]:\n\t\t\"\"\"Get all screenshots from history\"\"\"\n\t\treturn [h.state.screenshot for h in self.history if h.state.screenshot]\n\n\tdef action_names(self) -> list[str]:\n\t\t\"\"\"Get all action names from history\"\"\"\n\t\treturn [list(action.keys())[0] for action in self.model_actions()]\n\n\tdef model_thoughts(self) -> list[AgentBrain]:\n\t\t\"\"\"Get all thoughts from history\"\"\"\n\t\treturn [h.model_output.current_state for h in self.history if h.model_output]\n\n\tdef model_outputs(self) -> list[AgentOutput]:\n\t\t\"\"\"Get all model outputs from history\"\"\"\n\t\treturn [h.model_output for h in self.history if h.model_output]\n\n\t# get all actions with params\n\tdef model_actions(self) -> list[dict]:\n\t\t\"\"\"Get all actions from history\"\"\"\n\t\toutputs = []\n\n\t\tfor h in self.history:\n\t\t\tif h.model_output:\n\t\t\t\tfor action in h.model_output.action:\n\t\t\t\t\toutput = action.model_dump(exclude_none=True)\n\t\t\t\t\toutputs.append(output)\n\t\treturn outputs\n\n\tdef action_results(self) -> list[ActionResult]:\n\t\t\"\"\"Get all results from history\"\"\"\n\t\tresults = []\n\t\tfor h in self.history:\n\t\t\tresults.extend([r for r in h.result if r])\n\t\treturn results\n\n\tdef extracted_content(self) -> list[str]:\n\t\t\"\"\"Get all extracted content from history\"\"\"\n\t\tcontent = []\n\t\tfor h in self.history:\n\t\t\tcontent.extend([r.extracted_content for r in h.result if r.extracted_content])\n\t\treturn content\n\n\tdef model_actions_filtered(self, include: list[str] = []) -> list[dict]:\n\t\t\"\"\"Get all model actions from history as JSON\"\"\"\n\t\toutputs = self.model_actions()\n\t\tresult = []\n\t\tfor o in outputs:\n\t\t\tfor i in include:\n\t\t\t\tif i == list(o.keys())[0]:\n\t\t\t\t\tresult.append(o)\n\t\treturn result\n\n\nclass AgentError:\n\t\"\"\"Container for agent error handling\"\"\"\n\n\tVALIDATION_ERROR = 'Invalid model output format. Please follow the correct schema.'\n\tRATE_LIMIT_ERROR = 'Rate limit reached. Waiting before retry.'\n\tNO_VALID_ACTION = 'No valid action found'\n\n\t@staticmethod\n\tdef format_error(error: Exception, include_trace: bool = False) -> str:\n\t\t\"\"\"Format error message based on error type and optionally include trace\"\"\"\n\t\tmessage = ''\n\t\tif isinstance(error, ValidationError):\n\t\t\treturn f'{AgentError.VALIDATION_ERROR}\\nDetails: {str(error)}'\n\t\tif isinstance(error, RateLimitError):\n\t\t\treturn AgentError.RATE_LIMIT_ERROR\n\t\tif include_trace:\n\t\t\treturn f'{str(error)}\\nStacktrace:\\n{traceback.format_exc()}'\n\t\treturn f'{str(error)}'\n"
  },
  "browser_use/browser/views.py": {
    "isBinary": "false",
    "code": "from dataclasses import dataclass\nfrom typing import Any, Optional\n\nfrom pydantic import BaseModel\n\nfrom browser_use.dom.history_tree_processor.service import DOMHistoryElement\nfrom browser_use.dom.views import DOMState\n\n\n# Pydantic\nclass TabInfo(BaseModel):\n\t\"\"\"Represents information about a browser tab\"\"\"\n\n\tpage_id: int\n\turl: str\n\ttitle: str\n\n\n@dataclass\nclass BrowserState(DOMState):\n\turl: str\n\ttitle: str\n\ttabs: list[TabInfo]\n\tscreenshot: Optional[str] = None\n\n\n@dataclass\nclass BrowserStateHistory:\n\turl: str\n\ttitle: str\n\ttabs: list[TabInfo]\n\tinteracted_element: list[DOMHistoryElement | None] | list[None]\n\tscreenshot: Optional[str] = None\n\n\tdef to_dict(self) -> dict[str, Any]:\n\t\tdata = {}\n\t\tdata['tabs'] = [tab.model_dump() for tab in self.tabs]\n\t\tdata['screenshot'] = self.screenshot\n\t\tdata['interacted_element'] = [\n\t\t\tel.to_dict() if el else None for el in self.interacted_element\n\t\t]\n\t\tdata['url'] = self.url\n\t\tdata['title'] = self.title\n\t\treturn data\n\n\nclass BrowserError(Exception):\n\t\"\"\"Base class for all browser errors\"\"\"\n"
  },
  "browser_use/telemetry/views.py": {
    "isBinary": "false",
    "code": "from abc import ABC, abstractmethod\nfrom dataclasses import asdict, dataclass\nfrom typing import Any, Dict, Optional\n\n\n@dataclass\nclass BaseTelemetryEvent(ABC):\n    @property\n    @abstractmethod\n    def name(self) -> str:\n        pass\n\n    @property\n    def properties(self) -> Dict[str, Any]:\n        return {k: v for k, v in asdict(self).items() if k != \"name\"}\n\n\n@dataclass\nclass RegisteredFunction:\n    name: str\n    params: dict[str, Any]\n\n\n@dataclass\nclass ControllerRegisteredFunctionsTelemetryEvent(BaseTelemetryEvent):\n    registered_functions: list[RegisteredFunction]\n    name: str = \"controller_registered_functions\"\n\n\n@dataclass\nclass AgentRunTelemetryEvent(BaseTelemetryEvent):\n    agent_id: str\n    task: str\n    name: str = \"agent_run\"\n\n\n@dataclass\nclass AgentStepErrorTelemetryEvent(BaseTelemetryEvent):\n    agent_id: str\n    error: str\n    name: str = \"agent_step_error\"\n\n\n@dataclass\nclass AgentEndTelemetryEvent(BaseTelemetryEvent):\n    agent_id: str\n    task: str\n    steps: int\n    success: bool\n    error: Optional[str] = None\n    name: str = \"agent_end\"\n"
  },
  "browser_use/agent/tests.py": {
    "isBinary": "false",
    "code": "import pytest\n\nfrom browser_use.agent.views import (\n\tActionResult,\n\tAgentBrain,\n\tAgentHistory,\n\tAgentHistoryList,\n\tAgentOutput,\n)\nfrom browser_use.browser.views import BrowserState, BrowserStateHistory, TabInfo\nfrom browser_use.controller.registry.service import Registry\nfrom browser_use.controller.views import ClickElementAction, DoneAction, ExtractPageContentAction\nfrom browser_use.dom.views import DOMElementNode\n\n\n@pytest.fixture\ndef sample_browser_state():\n\treturn BrowserState(\n\t\turl='https://example.com',\n\t\ttitle='Example Page',\n\t\ttabs=[TabInfo(url='https://example.com', title='Example Page', page_id=1)],\n\t\tscreenshot='screenshot1.png',\n\t\telement_tree=DOMElementNode(\n\t\t\ttag_name='root',\n\t\t\tis_visible=True,\n\t\t\tparent=None,\n\t\t\txpath='',\n\t\t\tattributes={},\n\t\t\tchildren=[],\n\t\t),\n\t\tselector_map={},\n\t)\n\n\n@pytest.fixture\ndef action_registry():\n\tregistry = Registry()\n\n\t# Register the actions we need for testing\n\t@registry.action(\n\t\tdescription='Click an element', requires_browser=True, param_model=ClickElementAction\n\t)\n\tdef click_element(params: ClickElementAction, browser=None):\n\t\tpass\n\n\t@registry.action(\n\t\tdescription='Extract page content',\n\t\trequires_browser=True,\n\t\tparam_model=ExtractPageContentAction,\n\t)\n\tdef extract_page_content(params: ExtractPageContentAction, browser=None):\n\t\tpass\n\n\t@registry.action(description='Mark task as done', param_model=DoneAction)\n\tdef done(params: DoneAction):\n\t\tpass\n\n\t# Create the dynamic ActionModel with all registered actions\n\treturn registry.create_action_model()\n\n\n@pytest.fixture\ndef sample_history(action_registry):\n\t# Create actions with nested params structure\n\tclick_action = action_registry(click_element={'index': 1})\n\n\textract_action = action_registry(extract_page_content={'value': 'text'})\n\n\tdone_action = action_registry(done={'text': 'Task completed'})\n\n\thistories = [\n\t\tAgentHistory(\n\t\t\tmodel_output=AgentOutput(\n\t\t\t\tcurrent_state=AgentBrain(\n\t\t\t\t\tevaluation_previous_goal='None', memory='Started task', next_goal='Click button'\n\t\t\t\t),\n\t\t\t\taction=[click_action],\n\t\t\t),\n\t\t\tresult=[ActionResult(is_done=False)],\n\t\t\tstate=BrowserStateHistory(\n\t\t\t\turl='https://example.com',\n\t\t\t\ttitle='Page 1',\n\t\t\t\ttabs=[TabInfo(url='https://example.com', title='Page 1', page_id=1)],\n\t\t\t\tscreenshot='screenshot1.png',\n\t\t\t\tinteracted_element=[],\n\t\t\t),\n\t\t),\n\t\tAgentHistory(\n\t\t\tmodel_output=AgentOutput(\n\t\t\t\tcurrent_state=AgentBrain(\n\t\t\t\t\tevaluation_previous_goal='Clicked button',\n\t\t\t\t\tmemory='Button clicked',\n\t\t\t\t\tnext_goal='Extract content',\n\t\t\t\t),\n\t\t\t\taction=[extract_action],\n\t\t\t),\n\t\t\tresult=[\n\t\t\t\tActionResult(\n\t\t\t\t\tis_done=False,\n\t\t\t\t\textracted_content='Extracted text',\n\t\t\t\t\terror='Failed to extract completely',\n\t\t\t\t)\n\t\t\t],\n\t\t\tstate=BrowserStateHistory(\n\t\t\t\turl='https://example.com/page2',\n\t\t\t\ttitle='Page 2',\n\t\t\t\ttabs=[TabInfo(url='https://example.com/page2', title='Page 2', page_id=2)],\n\t\t\t\tscreenshot='screenshot2.png',\n\t\t\t\tinteracted_element=[],\n\t\t\t),\n\t\t),\n\t\tAgentHistory(\n\t\t\tmodel_output=AgentOutput(\n\t\t\t\tcurrent_state=AgentBrain(\n\t\t\t\t\tevaluation_previous_goal='Extracted content',\n\t\t\t\t\tmemory='Content extracted',\n\t\t\t\t\tnext_goal='Finish task',\n\t\t\t\t),\n\t\t\t\taction=[done_action],\n\t\t\t),\n\t\t\tresult=[ActionResult(is_done=True, extracted_content='Task completed', error=None)],\n\t\t\tstate=BrowserStateHistory(\n\t\t\t\turl='https://example.com/page2',\n\t\t\t\ttitle='Page 2',\n\t\t\t\ttabs=[TabInfo(url='https://example.com/page2', title='Page 2', page_id=2)],\n\t\t\t\tscreenshot='screenshot3.png',\n\t\t\t\tinteracted_element=[],\n\t\t\t),\n\t\t),\n\t]\n\treturn AgentHistoryList(history=histories)\n\n\ndef test_last_model_output(sample_history: AgentHistoryList):\n\tlast_output = sample_history.last_action()\n\tprint(last_output)\n\tassert last_output == {'done': {'text': 'Task completed'}}\n\n\ndef test_get_errors(sample_history: AgentHistoryList):\n\terrors = sample_history.errors()\n\tassert len(errors) == 1\n\tassert errors[0] == 'Failed to extract completely'\n\n\ndef test_final_result(sample_history: AgentHistoryList):\n\tassert sample_history.final_result() == 'Task completed'\n\n\ndef test_is_done(sample_history: AgentHistoryList):\n\tassert sample_history.is_done() == True\n\n\ndef test_urls(sample_history: AgentHistoryList):\n\turls = sample_history.urls()\n\tassert 'https://example.com' in urls\n\tassert 'https://example.com/page2' in urls\n\n\ndef test_all_screenshots(sample_history: AgentHistoryList):\n\tscreenshots = sample_history.screenshots()\n\tassert len(screenshots) == 3\n\tassert screenshots == ['screenshot1.png', 'screenshot2.png', 'screenshot3.png']\n\n\ndef test_all_model_outputs(sample_history: AgentHistoryList):\n\toutputs = sample_history.model_actions()\n\tassert len(outputs) == 3\n\tassert outputs[0] == {'click_element': {'index': 1, 'xpath': '//button[1]'}}\n\tassert outputs[1] == {'extract_page_content': {'value': 'text'}}\n\tassert outputs[2] == {'done': {'text': 'Task completed'}}\n\n\ndef test_all_model_outputs_filtered(sample_history: AgentHistoryList):\n\tfiltered = sample_history.model_actions_filtered(include=['click_element'])\n\tassert len(filtered) == 1\n\tassert filtered[0]['click_element']['index'] == 1\n\n\ndef test_empty_history():\n\tempty_history = AgentHistoryList(history=[])\n\tassert empty_history.last_action() is None\n\tassert empty_history.final_result() is None\n\tassert empty_history.is_done() == False\n\tassert len(empty_history.urls()) == 0\n\n\n# Add a test to verify action creation\ndef test_action_creation(action_registry):\n\tclick_action = action_registry(click_element={'index': 1})\n\n\tassert click_action.model_dump(exclude_none=True) == {'click_element': {'index': 1}}\n\n\n# run this with:\n# pytest browser_use/agent/tests.py\n"
  },
  "conftest.py": {
    "code": "import os\nimport sys\n\nfrom browser_use.logging_config import setup_logging\n\n# Get the absolute path to the project root\nproject_root = os.path.dirname(os.path.abspath(__file__))\nsys.path.insert(0, project_root)\n\nsetup_logging()\n",
    "isBinary": "false"
  },
  "browser_use/controller/views.py": {
    "code": "from typing import Literal, Optional\n\nfrom pydantic import BaseModel\n\n\n# Action Input Models\nclass SearchGoogleAction(BaseModel):\n\tquery: str\n\n\nclass GoToUrlAction(BaseModel):\n\turl: str\n\n\nclass ClickElementAction(BaseModel):\n\tindex: int\n\txpath: Optional[str] = None\n\n\nclass InputTextAction(BaseModel):\n\tindex: int\n\ttext: str\n\txpath: Optional[str] = None\n\n\nclass DoneAction(BaseModel):\n\ttext: str\n\n\nclass SwitchTabAction(BaseModel):\n\tpage_id: int\n\n\nclass OpenTabAction(BaseModel):\n\turl: str\n\n\nclass ExtractPageContentAction(BaseModel):\n\tvalue: Literal['text', 'markdown', 'html'] = 'text'\n\n\nclass ScrollAction(BaseModel):\n\tamount: Optional[int] = None  # The number of pixels to scroll. If None, scroll down/up one page\n\n\nclass SendKeysAction(BaseModel):\n\tkeys: str\n",
    "isBinary": "false"
  },
  ".python-version": {
    "code": "3.11",
    "isBinary": "false"
  },
  "examples/custom_output.py": {
    "code": "\"\"\"\nFind and apply to jobs.\n\n@dev You need to add OPENAI_API_KEY to your environment variables.\n\"\"\"\n\nimport os\nimport sys\n\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nimport asyncio\n\nfrom dotenv import load_dotenv\nfrom langchain_openai import ChatOpenAI\nfrom pydantic import BaseModel\n\nfrom browser_use import ActionResult, Agent, Controller\n\nload_dotenv()\n\ncontroller = Controller()\n\n\nclass DoneResult(BaseModel):\n\tpost_title: str\n\tpost_url: str\n\tnum_comments: int\n\thours_since_post: int\n\n\n@controller.registry.action('Done with task', param_model=DoneResult)\nasync def done(params: DoneResult):\n\tresult = ActionResult(is_done=True, extracted_content=params.model_dump_json())\n\treturn result\n\n\nasync def main():\n\ttask = 'Go to hackernews show hn and give me the number 1 post in the list'\n\tmodel = ChatOpenAI(model='gpt-4o')\n\tagent = Agent(task=task, llm=model, controller=controller)\n\n\thistory = await agent.run()\n\n\tresult = history.final_result()\n\tif result:\n\t\tparsed = DoneResult.model_validate_json(result)\n\t\tprint('--------------------------------')\n\t\tprint(f'Title: {parsed.post_title}')\n\t\tprint(f'URL: {parsed.post_url}')\n\t\tprint(f'Comments: {parsed.num_comments}')\n\t\tprint(f'Hours since post: {parsed.hours_since_post}')\n\n\nif __name__ == '__main__':\n\tasyncio.run(main())\n",
    "isBinary": "false"
  },
  "examples/find_and_apply_to_jobs.py": {
    "isBinary": "false",
    "code": "\"\"\"\nFind and apply to jobs.\n\n@dev You need to add OPENAI_API_KEY to your environment variables.\n\nAlso you have to install PyPDF2 to read pdf files: pip install PyPDF2\n\"\"\"\n\nimport csv\nimport os\nimport re\nimport sys\nfrom pathlib import Path\n\nfrom PyPDF2 import PdfReader\n\nfrom browser_use.browser.browser import Browser, BrowserConfig\n\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\nimport asyncio\nfrom typing import List, Optional\n\nfrom dotenv import load_dotenv\nfrom langchain_openai import AzureChatOpenAI, ChatOpenAI\nfrom pydantic import BaseModel, SecretStr\n\nfrom browser_use import ActionResult, Agent, Controller\nfrom browser_use.browser.context import BrowserContext\n\nload_dotenv()\nimport logging\n\nlogger = logging.getLogger(__name__)\n# full screen mode\ncontroller = Controller()\nCV = Path.cwd() / 'cv_04_24.pdf'\n\n\nclass Job(BaseModel):\n\ttitle: str\n\tlink: str\n\tcompany: str\n\tfit_score: float\n\tlocation: Optional[str] = None\n\tsalary: Optional[str] = None\n\n\n@controller.action(\n\t'Save jobs to file - with a score how well it fits to my profile', param_model=Job\n)\ndef save_jobs(job: Job):\n\twith open('jobs.csv', 'a', newline='') as f:\n\t\twriter = csv.writer(f)\n\t\twriter.writerow([job.title, job.company, job.link, job.salary, job.location])\n\n\treturn 'Saved job to file'\n\n\n@controller.action('Read jobs from file')\ndef read_jobs():\n\twith open('jobs.csv', 'r') as f:\n\t\treturn f.read()\n\n\n@controller.action('Read my cv for context to fill forms')\ndef read_cv():\n\tpdf = PdfReader(CV)\n\ttext = ''\n\tfor page in pdf.pages:\n\t\ttext += page.extract_text() or ''\n\tlogger.info(f'Read cv with {len(text)} characters')\n\treturn ActionResult(extracted_content=text, include_in_memory=True)\n\n\n@controller.action(\n\t'Upload cv to element - call this function to upload if element is not found, try with different index of the same upload element',\n\trequires_browser=True,\n)\nasync def upload_cv(index: int, browser: BrowserContext):\n\tpath = str(CV.absolute())\n\tdom_el = await browser.get_dom_element_by_index(index)\n\n\tif dom_el is None:\n\t\treturn ActionResult(error=f'No element found at index {index}')\n\n\tfile_upload_dom_el = dom_el.get_file_upload_element()\n\n\tif file_upload_dom_el is None:\n\t\tlogger.info(f'No file upload element found at index {index}')\n\t\treturn ActionResult(error=f'No file upload element found at index {index}')\n\n\tfile_upload_el = await browser.get_locate_element(file_upload_dom_el)\n\n\tif file_upload_el is None:\n\t\tlogger.info(f'No file upload element found at index {index}')\n\t\treturn ActionResult(error=f'No file upload element found at index {index}')\n\n\ttry:\n\t\tawait file_upload_el.set_input_files(path)\n\t\tmsg = f'Successfully uploaded file to index {index}'\n\t\tlogger.info(msg)\n\t\treturn ActionResult(extracted_content=msg)\n\texcept Exception as e:\n\t\tlogger.debug(f'Error in set_input_files: {str(e)}')\n\t\treturn ActionResult(error=f'Failed to upload file to index {index}')\n\n\nbrowser = Browser(\n\tconfig=BrowserConfig(\n\t\tchrome_instance_path='/Applications/Google Chrome.app/Contents/MacOS/Google Chrome',\n\t\tdisable_security=True,\n\t)\n)\n\n\nasync def main():\n\t# ground_task = (\n\t# \t'You are a professional job finder. '\n\t# \t'1. Read my cv with read_cv'\n\t# \t'2. Read the saved jobs file '\n\t# \t'3. start applying to the first link of Amazon '\n\t# \t'You can navigate through pages e.g. by scrolling '\n\t# \t'Make sure to be on the english version of the page'\n\t# )\n\tground_task = (\n\t\t'You are a professional job finder. '\n\t\t'1. Read my cv with read_cv'\n\t\t'find ml internships in and save them to a file'\n\t\t'search at company:'\n\t)\n\ttasks = [\n\t\tground_task + '\\n' + 'Google',\n\t\t# ground_task + '\\n' + 'Amazon',\n\t\t# ground_task + '\\n' + 'Apple',\n\t\t# ground_task + '\\n' + 'Microsoft',\n\t\t# ground_task\n\t\t# + '\\n'\n\t\t# + 'go to https://nvidia.wd5.myworkdayjobs.com/en-US/NVIDIAExternalCareerSite/job/Taiwan%2C-Remote/Fulfillment-Analyst---New-College-Graduate-2025_JR1988949/apply/autofillWithResume?workerSubType=0c40f6bd1d8f10adf6dae42e46d44a17&workerSubType=ab40a98049581037a3ada55b087049b7 NVIDIA',\n\t\t# ground_task + '\\n' + 'Meta',\n\t]\n\tmodel = AzureChatOpenAI(\n\t\tmodel='gpt-4o',\n\t\tapi_version='2024-10-21',\n\t\tazure_endpoint=os.getenv('AZURE_OPENAI_ENDPOINT', ''),\n\t\tapi_key=SecretStr(os.getenv('AZURE_OPENAI_KEY', '')),\n\t)\n\n\tagents = []\n\tfor task in tasks:\n\t\tagent = Agent(task=task, llm=model, controller=controller, browser=browser)\n\t\tagents.append(agent)\n\n\tawait asyncio.gather(*[agent.run() for agent in agents])\n\n\nif __name__ == '__main__':\n\tasyncio.run(main())\n"
  },
  "examples/parallel_agents.py": {
    "isBinary": "false",
    "code": "import os\nimport sys\n\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\nimport asyncio\n\nfrom langchain_openai import ChatOpenAI\n\nfrom browser_use.agent.service import Agent\nfrom browser_use.browser.browser import Browser, BrowserConfig\nfrom browser_use.browser.context import BrowserContextConfig\n\nbrowser = Browser(\n\tconfig=BrowserConfig(\n\t\tdisable_security=True,\n\t\theadless=False,\n\t\tnew_context_config=BrowserContextConfig(save_recording_path='./tmp/recordings'),\n\t)\n)\nllm = ChatOpenAI(model='gpt-4o')\n\n\nasync def main():\n\tagents = [\n\t\tAgent(task=task, llm=llm, browser=browser)\n\t\tfor task in [\n\t\t\t'Search Google for weather in Tokyo',\n\t\t\t'Check Reddit front page title',\n\t\t\t'Look up Bitcoin price on Coinbase',\n\t\t\t'Find NASA image of the day',\n\t\t\t# 'Check top story on CNN',\n\t\t\t# 'Search latest SpaceX launch date',\n\t\t\t# 'Look up population of Paris',\n\t\t\t# 'Find current time in Sydney',\n\t\t\t# 'Check who won last Super Bowl',\n\t\t\t# 'Search trending topics on Twitter',\n\t\t]\n\t]\n\n\tawait asyncio.gather(*[agent.run() for agent in agents])\n\n\t# async with await browser.new_context() as context:\n\tagentX = Agent(\n\t\ttask='Go to apple.com and return the title of the page',\n\t\tllm=llm,\n\t\tbrowser=browser,\n\t\t# browser_context=context,\n\t)\n\tawait agentX.run()\n\n\tawait browser.close()\n\n\nif __name__ == '__main__':\n\tasyncio.run(main())\n"
  },
  "browser_use/dom/history_tree_processor/service.py": {
    "isBinary": "false",
    "code": "import hashlib\nfrom dataclasses import dataclass\nfrom typing import Optional\n\nfrom browser_use.dom.history_tree_processor.view import DOMHistoryElement, HashedDomElement\nfrom browser_use.dom.views import DOMElementNode\n\n\nclass HistoryTreeProcessor:\n\t\"\"\" \"\n\tOperations on the DOM elements\n\n\t@dev be careful - text nodes can change even if elements stay the same\n\t\"\"\"\n\n\t@staticmethod\n\tdef convert_dom_element_to_history_element(dom_element: DOMElementNode) -> DOMHistoryElement:\n\t\tparent_branch_path = HistoryTreeProcessor._get_parent_branch_path(dom_element)\n\t\treturn DOMHistoryElement(\n\t\t\tdom_element.tag_name,\n\t\t\tdom_element.xpath,\n\t\t\tdom_element.highlight_index,\n\t\t\tparent_branch_path,\n\t\t\tdom_element.attributes,\n\t\t\tdom_element.shadow_root,\n\t\t)\n\n\t@staticmethod\n\tdef find_history_element_in_tree(\n\t\tdom_history_element: DOMHistoryElement, tree: DOMElementNode\n\t) -> Optional[DOMElementNode]:\n\t\thashed_dom_history_element = HistoryTreeProcessor._hash_dom_history_element(\n\t\t\tdom_history_element\n\t\t)\n\n\t\tdef process_node(node: DOMElementNode):\n\t\t\tif node.highlight_index is not None:\n\t\t\t\thashed_node = HistoryTreeProcessor._hash_dom_element(node)\n\t\t\t\tif hashed_node == hashed_dom_history_element:\n\t\t\t\t\treturn node\n\t\t\tfor child in node.children:\n\t\t\t\tif isinstance(child, DOMElementNode):\n\t\t\t\t\tresult = process_node(child)\n\t\t\t\t\tif result is not None:\n\t\t\t\t\t\treturn result\n\t\t\treturn None\n\n\t\treturn process_node(tree)\n\n\t@staticmethod\n\tdef compare_history_element_and_dom_element(\n\t\tdom_history_element: DOMHistoryElement, dom_element: DOMElementNode\n\t) -> bool:\n\t\thashed_dom_history_element = HistoryTreeProcessor._hash_dom_history_element(\n\t\t\tdom_history_element\n\t\t)\n\t\thashed_dom_element = HistoryTreeProcessor._hash_dom_element(dom_element)\n\n\t\treturn hashed_dom_history_element == hashed_dom_element\n\n\t@staticmethod\n\tdef _hash_dom_history_element(dom_history_element: DOMHistoryElement) -> HashedDomElement:\n\t\tbranch_path_hash = HistoryTreeProcessor._parent_branch_path_hash(\n\t\t\tdom_history_element.entire_parent_branch_path\n\t\t)\n\t\tattributes_hash = HistoryTreeProcessor._attributes_hash(dom_history_element.attributes)\n\n\t\treturn HashedDomElement(branch_path_hash, attributes_hash)\n\n\t@staticmethod\n\tdef _hash_dom_element(dom_element: DOMElementNode) -> HashedDomElement:\n\t\tparent_branch_path = HistoryTreeProcessor._get_parent_branch_path(dom_element)\n\t\tbranch_path_hash = HistoryTreeProcessor._parent_branch_path_hash(parent_branch_path)\n\t\tattributes_hash = HistoryTreeProcessor._attributes_hash(dom_element.attributes)\n\t\t# text_hash = DomTreeProcessor._text_hash(dom_element)\n\n\t\treturn HashedDomElement(branch_path_hash, attributes_hash)\n\n\t@staticmethod\n\tdef _get_parent_branch_path(dom_element: DOMElementNode) -> list[str]:\n\t\tparents: list[DOMElementNode] = []\n\t\tcurrent_element: DOMElementNode = dom_element\n\t\twhile current_element.parent is not None:\n\t\t\tparents.append(current_element)\n\t\t\tcurrent_element = current_element.parent\n\n\t\tparents.reverse()\n\n\t\treturn [parent.tag_name for parent in parents]\n\n\t@staticmethod\n\tdef _parent_branch_path_hash(parent_branch_path: list[str]) -> str:\n\t\tparent_branch_path_string = '/'.join(parent_branch_path)\n\t\treturn hashlib.sha256(parent_branch_path_string.encode()).hexdigest()\n\n\t@staticmethod\n\tdef _attributes_hash(attributes: dict[str, str]) -> str:\n\t\tattributes_string = ''.join(f'{key}={value}' for key, value in attributes.items())\n\t\treturn hashlib.sha256(attributes_string.encode()).hexdigest()\n\n\t@staticmethod\n\tdef _text_hash(dom_element: DOMElementNode) -> str:\n\t\t\"\"\" \"\"\"\n\t\ttext_string = dom_element.get_all_text_till_next_clickable_element()\n\t\treturn hashlib.sha256(text_string.encode()).hexdigest()\n"
  },
  "browser_use/README.md": {
    "code": "# Codebase Structure\n\n> The code structure inspired by https://github.com/Netflix/dispatch.\n\nVery good structure on how to make a scalable codebase is also in [this repo](https://github.com/zhanymkanov/fastapi-best-practices).\n\nJust a brief document about how we should structure our backend codebase.\n\n## Code Structure\n\n```markdown\nsrc/\n/<service name>/\nmodels.py\nservices.py\nprompts.py\nviews.py\nutils.py\nrouters.py\n\n    \t/_<subservice name>/\n```\n\n### Service.py\n\nAlways a single file, except if it becomes too long - more than ~500 lines, split it into \\_subservices\n\n### Views.py\n\nAlways split the views into two parts\n\n```python\n# All\n...\n\n# Requests\n...\n\n# Responses\n...\n```\n\nIf too long  split into multiple files\n\n### Prompts.py\n\nSingle file; if too long  split into multiple files (one prompt per file or so)\n\n### Routers.py\n\nNever split into more than one file\n",
    "isBinary": "false"
  },
  ".gitattributes": {
    "isBinary": "false",
    "code": "static/*.gif filter=lfs diff=lfs merge=lfs -text\n# static/*.mp4 filter=lfs diff=lfs merge=lfs -text\n"
  },
  "examples/captcha.py": {
    "code": "\"\"\"\nSimple try of the agent.\n\n@dev You need to add OPENAI_API_KEY to your environment variables.\n\"\"\"\n\nimport os\nimport sys\n\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nimport asyncio\n\nfrom langchain_openai import ChatOpenAI\n\nfrom browser_use import Agent\n\n# NOTE: captchas are hard. For this example it works. But e.g. for iframes it does not.\n# for this example it helps to zoom in.\nllm = ChatOpenAI(model='gpt-4o')\nagent = Agent(\n\ttask='go to https://captcha.com/demos/features/captcha-demo.aspx and solve the captcha',\n\tllm=llm,\n)\n\n\nasync def main():\n\tawait agent.run()\n\tinput('Press Enter to exit')\n\n\nasyncio.run(main())\n",
    "isBinary": "false"
  },
  "browser_use/agent/__pycache__/prompts.cpython-313.pyc": {
    "code": "",
    "isBinary": "true"
  },
  "browser_use/utils.py": {
    "isBinary": "false",
    "code": "import logging\nimport time\nfrom functools import wraps\nfrom typing import Any, Callable, Coroutine, ParamSpec, TypeVar\n\nlogger = logging.getLogger(__name__)\n\n\n# Define generic type variables for return type and parameters\nR = TypeVar('R')\nP = ParamSpec('P')\n\n\ndef time_execution_sync(additional_text: str = '') -> Callable[[Callable[P, R]], Callable[P, R]]:\n\tdef decorator(func: Callable[P, R]) -> Callable[P, R]:\n\t\t@wraps(func)\n\t\tdef wrapper(*args: P.args, **kwargs: P.kwargs) -> R:\n\t\t\tstart_time = time.time()\n\t\t\tresult = func(*args, **kwargs)\n\t\t\texecution_time = time.time() - start_time\n\t\t\tlogger.debug(f'{additional_text} Execution time: {execution_time:.2f} seconds')\n\t\t\treturn result\n\n\t\treturn wrapper\n\n\treturn decorator\n\n\ndef time_execution_async(\n\tadditional_text: str = '',\n) -> Callable[[Callable[P, Coroutine[Any, Any, R]]], Callable[P, Coroutine[Any, Any, R]]]:\n\tdef decorator(func: Callable[P, Coroutine[Any, Any, R]]) -> Callable[P, Coroutine[Any, Any, R]]:\n\t\t@wraps(func)\n\t\tasync def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:\n\t\t\tstart_time = time.time()\n\t\t\tresult = await func(*args, **kwargs)\n\t\t\texecution_time = time.time() - start_time\n\t\t\tlogger.debug(f'{additional_text} Execution time: {execution_time:.2f} seconds')\n\t\t\treturn result\n\n\t\treturn wrapper\n\n\treturn decorator\n\n\ndef singleton(cls):\n\tinstance = [None]\n\n\tdef wrapper(*args, **kwargs):\n\t\tif instance[0] is None:\n\t\t\tinstance[0] = cls(*args, **kwargs)\n\t\treturn instance[0]\n\n\treturn wrapper\n"
  },
  "examples/scrolling_page.py": {
    "isBinary": "false",
    "code": "import os\nimport sys\n\nfrom browser_use.browser.browser import Browser, BrowserConfig\n\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nimport asyncio\n\nfrom langchain_openai import ChatOpenAI\n\nfrom browser_use import Agent\n\n\"\"\"\nExample: Using the 'Scroll down' action.\n\nThis script demonstrates how the agent can navigate to a webpage and scroll down the content.\nIf no amount is specified, the agent will scroll down by one page height.\n\"\"\"\n\nllm = ChatOpenAI(model='gpt-4o')\n\nagent = Agent(\n\t# task=\"Navigate to 'https://en.wikipedia.org/wiki/Internet' and scroll down by one page - then scroll up by 100 pixels - then scroll down by 100 pixels - then scroll down by 10000 pixels.\",\n\ttask=\"Navigate to 'https://en.wikipedia.org/wiki/Internet' and to The vast majority of computer\",\n\tllm=llm,\n\tbrowser=Browser(config=BrowserConfig(headless=False)),\n)\n\n\nasync def main():\n\tawait agent.run()\n\n\nif __name__ == '__main__':\n\tasyncio.run(main())\n"
  },
  "browser_use/agent/service.py": {
    "isBinary": "false",
    "code": "from __future__ import annotations\n\nimport asyncio\nimport json\nimport logging\nimport os\nimport time\nimport uuid\nfrom pathlib import Path\nfrom typing import Any, Optional, Type, TypeVar\n\nfrom dotenv import load_dotenv\nfrom langchain_core.language_models.chat_models import BaseChatModel\nfrom langchain_core.messages import (\n\tBaseMessage,\n\tSystemMessage,\n)\nfrom openai import RateLimitError\nfrom pydantic import BaseModel, ValidationError\n\nfrom browser_use.agent.message_manager.service import MessageManager\nfrom browser_use.agent.prompts import AgentMessagePrompt, SystemPrompt\nfrom browser_use.agent.views import (\n\tActionResult,\n\tAgentError,\n\tAgentHistory,\n\tAgentHistoryList,\n\tAgentOutput,\n\tAgentStepInfo,\n)\nfrom browser_use.browser.browser import Browser\nfrom browser_use.browser.context import BrowserContext\nfrom browser_use.browser.views import BrowserState, BrowserStateHistory\nfrom browser_use.controller.registry.views import ActionModel\nfrom browser_use.controller.service import Controller\nfrom browser_use.dom.history_tree_processor.service import (\n\tDOMHistoryElement,\n\tHistoryTreeProcessor,\n)\nfrom browser_use.telemetry.service import ProductTelemetry\nfrom browser_use.telemetry.views import (\n\tAgentEndTelemetryEvent,\n\tAgentRunTelemetryEvent,\n\tAgentStepErrorTelemetryEvent,\n)\nfrom browser_use.utils import time_execution_async\n\nload_dotenv()\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T', bound=BaseModel)\n\n\nclass Agent:\n\tdef __init__(\n\t\tself,\n\t\ttask: str,\n\t\tllm: BaseChatModel,\n\t\tbrowser: Browser | None = None,\n\t\tbrowser_context: BrowserContext | None = None,\n\t\tcontroller: Controller = Controller(),\n\t\tuse_vision: bool = True,\n\t\tsave_conversation_path: Optional[str] = None,\n\t\tmax_failures: int = 5,\n\t\tretry_delay: int = 10,\n\t\tsystem_prompt_class: Type[SystemPrompt] = SystemPrompt,\n\t\tmax_input_tokens: int = 128000,\n\t\tvalidate_output: bool = False,\n\t\tinclude_attributes: list[str] = [\n\t\t\t'title',\n\t\t\t'type',\n\t\t\t'name',\n\t\t\t'role',\n\t\t\t'tabindex',\n\t\t\t'aria-label',\n\t\t\t'placeholder',\n\t\t\t'value',\n\t\t\t'alt',\n\t\t\t'aria-expanded',\n\t\t],\n\t\tmax_error_length: int = 400,\n\t\tmax_actions_per_step: int = 10,\n\t):\n\t\tself.agent_id = str(uuid.uuid4())  # unique identifier for the agent\n\n\t\tself.task = task\n\t\tself.use_vision = use_vision\n\t\tself.llm = llm\n\t\tself.save_conversation_path = save_conversation_path\n\t\tself._last_result = None\n\t\tself.include_attributes = include_attributes\n\t\tself.max_error_length = max_error_length\n\t\t# Controller setup\n\t\tself.controller = controller\n\t\tself.max_actions_per_step = max_actions_per_step\n\n\t\t# Browser setup\n\t\tself.injected_browser = browser is not None\n\t\tself.injected_browser_context = browser_context is not None\n\n\t\t# Initialize browser first if needed\n\t\tself.browser = browser if browser is not None else (None if browser_context else Browser())\n\n\t\t# Initialize browser context\n\t\tif browser_context:\n\t\t\tself.browser_context = browser_context\n\t\telif self.browser:\n\t\t\tself.browser_context = BrowserContext(\n\t\t\t\tbrowser=self.browser, config=self.browser.config.new_context_config\n\t\t\t)\n\t\telse:\n\t\t\t# If neither is provided, create both new\n\t\t\tself.browser = Browser()\n\t\t\tself.browser_context = BrowserContext(browser=self.browser)\n\n\t\tself.system_prompt_class = system_prompt_class\n\n\t\t# Telemetry setup\n\t\tself.telemetry = ProductTelemetry()\n\n\t\t# Action and output models setup\n\t\tself._setup_action_models()\n\n\t\tself.max_input_tokens = max_input_tokens\n\n\t\tself.message_manager = MessageManager(\n\t\t\tllm=self.llm,\n\t\t\ttask=self.task,\n\t\t\taction_descriptions=self.controller.registry.get_prompt_description(),\n\t\t\tsystem_prompt_class=self.system_prompt_class,\n\t\t\tmax_input_tokens=self.max_input_tokens,\n\t\t\tinclude_attributes=self.include_attributes,\n\t\t\tmax_error_length=self.max_error_length,\n\t\t\tmax_actions_per_step=self.max_actions_per_step,\n\t\t)\n\n\t\t# Tracking variables\n\t\tself.history: AgentHistoryList = AgentHistoryList(history=[])\n\t\tself.n_steps = 1\n\t\tself.consecutive_failures = 0\n\t\tself.max_failures = max_failures\n\t\tself.retry_delay = retry_delay\n\t\tself.validate_output = validate_output\n\n\t\tif save_conversation_path:\n\t\t\tlogger.info(f'Saving conversation to {save_conversation_path}')\n\n\tdef _setup_action_models(self) -> None:\n\t\t\"\"\"Setup dynamic action models from controller's registry\"\"\"\n\t\t# Get the dynamic action model from controller's registry\n\t\tself.ActionModel = self.controller.registry.create_action_model()\n\t\t# Create output model with the dynamic actions\n\t\tself.AgentOutput = AgentOutput.type_with_custom_actions(self.ActionModel)\n\n\t@time_execution_async('--step')\n\tasync def step(self, step_info: Optional[AgentStepInfo] = None) -> None:\n\t\t\"\"\"Execute one step of the task\"\"\"\n\t\tlogger.info(f'\\n Step {self.n_steps}')\n\t\tstate = None\n\t\tmodel_output = None\n\t\tresult: list[ActionResult] = []\n\n\t\ttry:\n\t\t\tstate = await self.browser_context.get_state(use_vision=self.use_vision)\n\t\t\tself.message_manager.add_state_message(state, self._last_result, step_info)\n\t\t\tinput_messages = self.message_manager.get_messages()\n\t\t\tmodel_output = await self.get_next_action(input_messages)\n\t\t\tself._save_conversation(input_messages, model_output)\n\t\t\tself.message_manager._remove_last_state_message()  # we dont want the whole state in the chat history\n\t\t\tself.message_manager.add_model_output(model_output)\n\n\t\t\tresult: list[ActionResult] = await self.controller.multi_act(\n\t\t\t\tmodel_output.action, self.browser_context\n\t\t\t)\n\t\t\tself._last_result = result\n\n\t\t\tif len(result) > 0 and result[-1].is_done:\n\t\t\t\tlogger.info(f' Result: {result[-1].extracted_content}')\n\n\t\t\tself.consecutive_failures = 0\n\n\t\texcept Exception as e:\n\t\t\tresult = self._handle_step_error(e)\n\t\t\tself._last_result = result\n\n\t\tfinally:\n\t\t\tif not result:\n\t\t\t\treturn\n\t\t\tfor r in result:\n\t\t\t\tif r.error:\n\t\t\t\t\tself.telemetry.capture(\n\t\t\t\t\t\tAgentStepErrorTelemetryEvent(\n\t\t\t\t\t\t\tagent_id=self.agent_id,\n\t\t\t\t\t\t\terror=r.error,\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\tif state:\n\t\t\t\tself._make_history_item(model_output, state, result)\n\n\tdef _handle_step_error(self, error: Exception) -> list[ActionResult]:\n\t\t\"\"\"Handle all types of errors that can occur during a step\"\"\"\n\t\tinclude_trace = logger.isEnabledFor(logging.DEBUG)\n\t\terror_msg = AgentError.format_error(error, include_trace=include_trace)\n\t\tprefix = f' Result failed {self.consecutive_failures + 1}/{self.max_failures} times:\\n '\n\n\t\tif isinstance(error, (ValidationError, ValueError)):\n\t\t\tlogger.error(f'{prefix}{error_msg}')\n\t\t\tif 'Max token limit reached' in error_msg:\n\t\t\t\t# cut tokens from history\n\t\t\t\tself.message_manager.max_input_tokens = self.max_input_tokens - 500\n\t\t\t\tlogger.info(\n\t\t\t\t\tf'Cutting tokens from history - new max input tokens: {self.message_manager.max_input_tokens}'\n\t\t\t\t)\n\t\t\t\tself.message_manager.cut_messages()\n\t\t\tself.consecutive_failures += 1\n\t\telif isinstance(error, RateLimitError):\n\t\t\tlogger.warning(f'{prefix}{error_msg}')\n\t\t\ttime.sleep(self.retry_delay)\n\t\t\tself.consecutive_failures += 1\n\t\telse:\n\t\t\tlogger.error(f'{prefix}{error_msg}')\n\t\t\tself.consecutive_failures += 1\n\n\t\treturn [ActionResult(error=error_msg, include_in_memory=True)]\n\n\tdef _make_history_item(\n\t\tself,\n\t\tmodel_output: AgentOutput | None,\n\t\tstate: BrowserState,\n\t\tresult: list[ActionResult],\n\t) -> None:\n\t\t\"\"\"Create and store history item\"\"\"\n\t\tinteracted_element = None\n\t\tlen_result = len(result)\n\n\t\tif model_output:\n\t\t\tinteracted_elements = AgentHistory.get_interacted_element(\n\t\t\t\tmodel_output, state.selector_map\n\t\t\t)\n\t\telse:\n\t\t\tinteracted_elements = [None]\n\n\t\tstate_history = BrowserStateHistory(\n\t\t\turl=state.url,\n\t\t\ttitle=state.title,\n\t\t\ttabs=state.tabs,\n\t\t\tinteracted_element=interacted_elements,\n\t\t\tscreenshot=state.screenshot,\n\t\t)\n\n\t\thistory_item = AgentHistory(model_output=model_output, result=result, state=state_history)\n\n\t\tself.history.history.append(history_item)\n\n\t@time_execution_async('--get_next_action')\n\tasync def get_next_action(self, input_messages: list[BaseMessage]) -> AgentOutput:\n\t\t\"\"\"Get next action from LLM based on current state\"\"\"\n\n\t\tstructured_llm = self.llm.with_structured_output(self.AgentOutput, include_raw=True)\n\t\tresponse: dict[str, Any] = await structured_llm.ainvoke(input_messages)  # type: ignore\n\n\t\tparsed: AgentOutput = response['parsed']\n\t\t# cut the number of actions to max_actions_per_step\n\t\tparsed.action = parsed.action[: self.max_actions_per_step]\n\t\tself._log_response(parsed)\n\t\tself.n_steps += 1\n\n\t\treturn parsed\n\n\tdef _log_response(self, response: AgentOutput) -> None:\n\t\t\"\"\"Log the model's response\"\"\"\n\t\tif 'Success' in response.current_state.evaluation_previous_goal:\n\t\t\temoji = ''\n\t\telif 'Failed' in response.current_state.evaluation_previous_goal:\n\t\t\temoji = ''\n\t\telse:\n\t\t\temoji = ''\n\n\t\tlogger.info(f'{emoji} Eval: {response.current_state.evaluation_previous_goal}')\n\t\tlogger.info(f' Memory: {response.current_state.memory}')\n\t\tlogger.info(f' Next goal: {response.current_state.next_goal}')\n\t\tfor i, action in enumerate(response.action):\n\t\t\tlogger.info(\n\t\t\t\tf'  Action {i + 1}/{len(response.action)}: {action.model_dump_json(exclude_unset=True)}'\n\t\t\t)\n\n\tdef _save_conversation(self, input_messages: list[BaseMessage], response: Any) -> None:\n\t\t\"\"\"Save conversation history to file if path is specified\"\"\"\n\t\tif not self.save_conversation_path:\n\t\t\treturn\n\n\t\t# create folders if not exists\n\t\tos.makedirs(os.path.dirname(self.save_conversation_path), exist_ok=True)\n\n\t\twith open(self.save_conversation_path + f'_{self.n_steps}.txt', 'w') as f:\n\t\t\tself._write_messages_to_file(f, input_messages)\n\t\t\tself._write_response_to_file(f, response)\n\n\tdef _write_messages_to_file(self, f: Any, messages: list[BaseMessage]) -> None:\n\t\t\"\"\"Write messages to conversation file\"\"\"\n\t\tfor message in messages:\n\t\t\tf.write(f' {message.__class__.__name__} \\n')\n\n\t\t\tif isinstance(message.content, list):\n\t\t\t\tfor item in message.content:\n\t\t\t\t\tif isinstance(item, dict) and item.get('type') == 'text':\n\t\t\t\t\t\tf.write(item['text'].strip() + '\\n')\n\t\t\telif isinstance(message.content, str):\n\t\t\t\ttry:\n\t\t\t\t\tcontent = json.loads(message.content)\n\t\t\t\t\tf.write(json.dumps(content, indent=2) + '\\n')\n\t\t\t\texcept json.JSONDecodeError:\n\t\t\t\t\tf.write(message.content.strip() + '\\n')\n\n\t\t\tf.write('\\n')\n\n\tdef _write_response_to_file(self, f: Any, response: Any) -> None:\n\t\t\"\"\"Write model response to conversation file\"\"\"\n\t\tf.write(' RESPONSE\\n')\n\t\tf.write(json.dumps(json.loads(response.model_dump_json(exclude_unset=True)), indent=2))\n\n\tasync def run(self, max_steps: int = 100) -> AgentHistoryList:\n\t\t\"\"\"Execute the task with maximum number of steps\"\"\"\n\t\ttry:\n\t\t\tlogger.info(f' Starting task: {self.task}')\n\n\t\t\tself.telemetry.capture(\n\t\t\t\tAgentRunTelemetryEvent(\n\t\t\t\t\tagent_id=self.agent_id,\n\t\t\t\t\ttask=self.task,\n\t\t\t\t)\n\t\t\t)\n\n\t\t\tfor step in range(max_steps):\n\t\t\t\tif self._too_many_failures():\n\t\t\t\t\tbreak\n\n\t\t\t\tawait self.step()\n\n\t\t\t\tif self.history.is_done():\n\t\t\t\t\tif (\n\t\t\t\t\t\tself.validate_output and step < max_steps - 1\n\t\t\t\t\t):  # if last step, we dont need to validate\n\t\t\t\t\t\tif not await self._validate_output():\n\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\tlogger.info(' Task completed successfully')\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tlogger.info(' Failed to complete task in maximum steps')\n\n\t\t\treturn self.history\n\n\t\tfinally:\n\t\t\tself.telemetry.capture(\n\t\t\t\tAgentEndTelemetryEvent(\n\t\t\t\t\tagent_id=self.agent_id,\n\t\t\t\t\ttask=self.task,\n\t\t\t\t\tsuccess=self.history.is_done(),\n\t\t\t\t\tsteps=len(self.history.history),\n\t\t\t\t)\n\t\t\t)\n\t\t\tif not self.injected_browser_context:\n\t\t\t\tawait self.browser_context.close()\n\n\t\t\tif not self.injected_browser and self.browser:\n\t\t\t\tawait self.browser.close()\n\n\tdef _too_many_failures(self) -> bool:\n\t\t\"\"\"Check if we should stop due to too many failures\"\"\"\n\t\tif self.consecutive_failures >= self.max_failures:\n\t\t\tlogger.error(f' Stopping due to {self.max_failures} consecutive failures')\n\t\t\treturn True\n\t\treturn False\n\n\tasync def _validate_output(self) -> bool:\n\t\t\"\"\"Validate the output of the last action is what the user wanted\"\"\"\n\t\tsystem_msg = (\n\t\t\tf'You are a validator of an agent who interacts with a browser. '\n\t\t\tf'Validate if the output of last action is what the user wanted and if the task is completed. '\n\t\t\tf'If the task is unclear defined, you can let it pass. But if something is missing or the image does not show what was requested dont let it pass. '\n\t\t\tf'Try to understand the page and help the model with suggestions like scroll, do x, ... to get the solution right. '\n\t\t\tf'Task to validate: {self.task}. Return a JSON object with 2 keys: is_valid and reason. '\n\t\t\tf'is_valid is a boolean that indicates if the output is correct. '\n\t\t\tf'reason is a string that explains why it is valid or not.'\n\t\t\tf' example: {{\"is_valid\": false, \"reason\": \"The user wanted to search for \"cat photos\", but the agent searched for \"dog photos\" instead.\"}}'\n\t\t)\n\n\t\tif self.browser_context.session:\n\t\t\tstate = await self.browser_context.get_state(use_vision=self.use_vision)\n\t\t\tcontent = AgentMessagePrompt(\n\t\t\t\tstate=state,\n\t\t\t\tresult=self._last_result,\n\t\t\t\tinclude_attributes=self.include_attributes,\n\t\t\t\tmax_error_length=self.max_error_length,\n\t\t\t)\n\t\t\tmsg = [SystemMessage(content=system_msg), content.get_user_message()]\n\t\telse:\n\t\t\t# if no browser session, we can't validate the output\n\t\t\treturn True\n\n\t\tclass ValidationResult(BaseModel):\n\t\t\tis_valid: bool\n\t\t\treason: str\n\n\t\tvalidator = self.llm.with_structured_output(ValidationResult, include_raw=True)\n\t\tresponse: dict[str, Any] = await validator.ainvoke(msg)  # type: ignore\n\t\tparsed: ValidationResult = response['parsed']\n\t\tis_valid = parsed.is_valid\n\t\tif not is_valid:\n\t\t\tlogger.info(f' Validator decision: {parsed.reason}')\n\t\t\tmsg = f'The ouput is not yet correct. {parsed.reason}.'\n\t\t\tself._last_result = [ActionResult(extracted_content=msg, include_in_memory=True)]\n\t\telse:\n\t\t\tlogger.info(f' Validator decision: {parsed.reason}')\n\t\treturn is_valid\n\n\tasync def rerun_history(\n\t\tself,\n\t\thistory: AgentHistoryList,\n\t\tmax_retries: int = 3,\n\t\tskip_failures: bool = True,\n\t\tdelay_between_actions: float = 2.0,\n\t) -> list[ActionResult]:\n\t\t\"\"\"\n\t\tRerun a saved history of actions with error handling and retry logic.\n\n\t\tArgs:\n\t\t        history: The history to replay\n\t\t        max_retries: Maximum number of retries per action\n\t\t        skip_failures: Whether to skip failed actions or stop execution\n\t\t        delay_between_actions: Delay between actions in seconds\n\n\t\tReturns:\n\t\t        List of action results\n\t\t\"\"\"\n\t\tresults = []\n\n\t\tfor i, history_item in enumerate(history.history):\n\t\t\tgoal = (\n\t\t\t\thistory_item.model_output.current_state.next_goal\n\t\t\t\tif history_item.model_output\n\t\t\t\telse ''\n\t\t\t)\n\t\t\tlogger.info(f'Replaying step {i + 1}/{len(history.history)}: goal: {goal}')\n\n\t\t\tif (\n\t\t\t\tnot history_item.model_output\n\t\t\t\tor not history_item.model_output.action\n\t\t\t\tor history_item.model_output.action == [None]\n\t\t\t):\n\t\t\t\tlogger.warning(f'Step {i + 1}: No action to replay, skipping')\n\t\t\t\tresults.append(ActionResult(error='No action to replay'))\n\t\t\t\tcontinue\n\n\t\t\tretry_count = 0\n\t\t\twhile retry_count < max_retries:\n\t\t\t\ttry:\n\t\t\t\t\tresult = await self._execute_history_step(history_item, delay_between_actions)\n\t\t\t\t\tresults.extend(result)\n\t\t\t\t\tbreak\n\n\t\t\t\texcept Exception as e:\n\t\t\t\t\tretry_count += 1\n\t\t\t\t\tif retry_count == max_retries:\n\t\t\t\t\t\terror_msg = f'Step {i + 1} failed after {max_retries} attempts: {str(e)}'\n\t\t\t\t\t\tlogger.error(error_msg)\n\t\t\t\t\t\tif not skip_failures:\n\t\t\t\t\t\t\tresults.append(ActionResult(error=error_msg))\n\t\t\t\t\t\t\traise RuntimeError(error_msg)\n\t\t\t\t\telse:\n\t\t\t\t\t\tlogger.warning(\n\t\t\t\t\t\t\tf'Step {i + 1} failed (attempt {retry_count}/{max_retries}), retrying...'\n\t\t\t\t\t\t)\n\t\t\t\t\t\tawait asyncio.sleep(delay_between_actions)\n\n\t\treturn results\n\n\tasync def _execute_history_step(\n\t\tself, history_item: AgentHistory, delay: float\n\t) -> list[ActionResult]:\n\t\t\"\"\"Execute a single step from history with element validation\"\"\"\n\n\t\tstate = await self.browser_context.get_state()\n\t\tif not state or not history_item.model_output:\n\t\t\traise ValueError('Invalid state or model output')\n\t\tupdated_actions = []\n\t\tfor i, action in enumerate(history_item.model_output.action):\n\t\t\tupdated_action = await self._update_action_indices(\n\t\t\t\thistory_item.state.interacted_element[i],\n\t\t\t\taction,\n\t\t\t\tstate,\n\t\t\t)\n\t\t\tupdated_actions.append(updated_action)\n\n\t\t\tif updated_action is None:\n\t\t\t\traise ValueError(f'Could not find matching element {i} in current page')\n\n\t\tresult = await self.controller.multi_act(updated_actions, self.browser_context)\n\n\t\tawait asyncio.sleep(delay)\n\t\treturn result\n\n\tasync def _update_action_indices(\n\t\tself,\n\t\thistorical_element: Optional[DOMHistoryElement],\n\t\taction: ActionModel,  # Type this properly based on your action model\n\t\tcurrent_state: BrowserState,\n\t) -> Optional[ActionModel]:\n\t\t\"\"\"\n\t\tUpdate action indices based on current page state.\n\t\tReturns updated action or None if element cannot be found.\n\t\t\"\"\"\n\t\tif not historical_element or not current_state.element_tree:\n\t\t\treturn action\n\n\t\tcurrent_element = HistoryTreeProcessor.find_history_element_in_tree(\n\t\t\thistorical_element, current_state.element_tree\n\t\t)\n\n\t\tif not current_element or current_element.highlight_index is None:\n\t\t\treturn None\n\n\t\told_index = action.get_index()\n\t\tif old_index != current_element.highlight_index:\n\t\t\taction.set_index(current_element.highlight_index)\n\t\t\tlogger.info(\n\t\t\t\tf'Element moved in DOM, updated index from {old_index} to {current_element.highlight_index}'\n\t\t\t)\n\n\t\treturn action\n\n\tasync def load_and_rerun(\n\t\tself, history_file: Optional[str | Path] = None, **kwargs\n\t) -> list[ActionResult]:\n\t\t\"\"\"\n\t\tLoad history from file and rerun it.\n\n\t\tArgs:\n\t\t        history_file: Path to the history file\n\t\t        **kwargs: Additional arguments passed to rerun_history\n\t\t\"\"\"\n\t\tif not history_file:\n\t\t\thistory_file = 'AgentHistory.json'\n\t\thistory = AgentHistoryList.load_from_file(history_file, self.AgentOutput)\n\t\treturn await self.rerun_history(history, **kwargs)\n\n\tdef save_history(self, file_path: Optional[str | Path] = None) -> None:\n\t\t\"\"\"Save the history to a file\"\"\"\n\t\tif not file_path:\n\t\t\tfile_path = 'AgentHistory.json'\n\t\tself.history.save_to_file(file_path)\n"
  },
  "examples/custom_system_prompt.py": {
    "code": "import json\nimport os\nimport sys\n\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nimport asyncio\n\nfrom langchain_openai import ChatOpenAI\n\nfrom browser_use import Agent, SystemPrompt\n\n\nclass MySystemPrompt(SystemPrompt):\n\tdef important_rules(self) -> str:\n\t\texisting_rules = super().important_rules()\n\t\tnew_rules = 'REMEBER the most importnat RULE: ALWAYS open first a new tab and go first to url wikipedia.com no matter the task!!!'\n\t\treturn f'{existing_rules}\\n{new_rules}'\n\n\t\t# other methods can be overriden as well (not recommended)\n\n\nasync def main():\n\ttask = 'do google search to find images of elon musk wife'\n\tmodel = ChatOpenAI(model='gpt-4o')\n\tagent = Agent(task=task, llm=model, system_prompt_class=MySystemPrompt)\n\n\tprint(\n\t\tjson.dumps(\n\t\t\tagent.message_manager.system_prompt.model_dump(exclude_unset=True),\n\t\t\tindent=4,\n\t\t)\n\t)\n\n\tawait agent.run()\n\n\nif __name__ == '__main__':\n\tasyncio.run(main())\n",
    "isBinary": "false"
  },
  "browser_use/dom/history_tree_processor/view.py": {
    "code": "from dataclasses import dataclass\nfrom typing import Optional\n\n\n@dataclass\nclass HashedDomElement:\n\t\"\"\"\n\tHash of the dom element to be used as a unique identifier\n\t\"\"\"\n\n\tbranch_path_hash: str\n\tattributes_hash: str\n\t# text_hash: str\n\n\n@dataclass\nclass DOMHistoryElement:\n\ttag_name: str\n\txpath: str\n\thighlight_index: Optional[int]\n\tentire_parent_branch_path: list[str]\n\tattributes: dict[str, str]\n\tshadow_root: bool = False\n\n\tdef to_dict(self) -> dict:\n\t\treturn {\n\t\t\t'tag_name': self.tag_name,\n\t\t\t'xpath': self.xpath,\n\t\t\t'highlight_index': self.highlight_index,\n\t\t\t'entire_parent_branch_path': self.entire_parent_branch_path,\n\t\t\t'attributes': self.attributes,\n\t\t\t'shadow_root': self.shadow_root,\n\t\t}\n",
    "isBinary": "false"
  },
  "pytest.ini": {
    "isBinary": "false",
    "code": "[pytest]\nmarkers =\n    slow: marks tests as slow (deselect with '-m \"not slow\"')\n    integration: marks tests as integration tests\n    unit: marks tests as unit tests\n\ntestpaths =\n    tests\n\npython_files =\n    test_*.py\n    *_test.py\n\naddopts =\n    -v\n    --strict-markers\n    --tb=short\n\nasyncio_mode = auto\nasyncio_default_fixture_loop_scope = function\nlog_cli = true\n; log_cli_level = DEBUG\nlog_cli_format = %(levelname)-8s [%(name)s] %(message)s\nfilterwarnings =\n    ignore::pytest.PytestDeprecationWarning\n    ignore::DeprecationWarning\n\nlog_level = INFO\n\n"
  },
  "examples/result_processing.py": {
    "code": "import os\nimport sys\nfrom pprint import pprint\n\nfrom browser_use.browser.browser import Browser, BrowserConfig\nfrom browser_use.browser.context import (\n\tBrowserContext,\n\tBrowserContextConfig,\n\tBrowserContextWindowSize,\n)\n\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\nimport asyncio\n\nfrom langchain_openai import ChatOpenAI\n\nfrom browser_use import Agent\nfrom browser_use.agent.views import AgentHistoryList\nfrom browser_use.controller.service import Controller\n\nllm = ChatOpenAI(model='gpt-4o')\nbrowser = Browser(\n\tconfig=BrowserConfig(\n\t\theadless=False,\n\t\tdisable_security=True,\n\t\textra_chromium_args=['--window-size=2000,2000'],\n\t)\n)\n\n\nasync def main():\n\tasync with await browser.new_context(\n\t\tconfig=BrowserContextConfig(\n\t\t\ttrace_path='./tmp/result_processing',\n\t\t\tno_viewport=False,\n\t\t\tbrowser_window_size=BrowserContextWindowSize(width=1280, height=1000),\n\t\t)\n\t) as browser_context:\n\t\tagent = Agent(\n\t\t\ttask=\"go to google.com and type 'OpenAI' click search and give me the first url\",\n\t\t\tllm=llm,\n\t\t\tbrowser_context=browser_context,\n\t\t)\n\t\thistory: AgentHistoryList = await agent.run(max_steps=3)\n\n\t\tprint('Final Result:')\n\t\tpprint(history.final_result(), indent=4)\n\n\t\tprint('\\nErrors:')\n\t\tpprint(history.errors(), indent=4)\n\n\t\t# e.g. xPaths the model clicked on\n\t\tprint('\\nModel Outputs:')\n\t\tpprint(history.model_actions(), indent=4)\n\n\t\tprint('\\nThoughts:')\n\t\tpprint(history.model_thoughts(), indent=4)\n\t# close browser\n\tawait browser.close()\n\n\nif __name__ == '__main__':\n\tasyncio.run(main())\n",
    "isBinary": "false"
  },
  ".gitignore": {
    "code": "# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\nshare/python-wheels/\n*.egg-info/\n.installed.cfg\n*.egg\nMANIFEST\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.nox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*.cover\n*.py,cover\n.hypothesis/\n.pytest_cache/\ncover/\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\nlocal_settings.py\ndb.sqlite3\ndb.sqlite3-journal\n\n# Flask stuff:\ninstance/\n.webassets-cache\n\n# Scrapy stuff:\n.scrapy\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\n.pybuilder/\ntarget/\n\n# Jupyter Notebook\n.ipynb_checkpoints\n\n# IPython\nprofile_default/\nipython_config.py\n\n# pyenv\n#   For a library or package, you might want to ignore these files since the code is\n#   intended to run in multiple environments; otherwise, check them in:\n# .python-version\n\n# pipenv\n#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.\n#   However, in case of collaboration, if having platform-specific dependencies or dependencies\n#   having no cross-platform support, pipenv may install dependencies that don't work, or not\n#   install all needed dependencies.\n#Pipfile.lock\n\n# poetry\n#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.\n#   This is especially recommended for binary packages to ensure reproducibility, and is more\n#   commonly ignored for libraries.\n#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control\n#poetry.lock\n\n# pdm\n#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.\n#pdm.lock\n#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it\n#   in version control.\n#   https://pdm.fming.dev/latest/usage/project/#working-with-version-control\n.pdm.toml\n.pdm-python\n.pdm-build/\n\n# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm\n__pypackages__/\n\n# Celery stuff\ncelerybeat-schedule\ncelerybeat.pid\n\n# SageMath parsed files\n*.sage.py\n\n# Environments\n.env\n.venv\nenv/\nvenv/\nENV/\nenv.bak/\nvenv.bak/\ntest_env/\n\n\n# Spyder project settings\n.spyderproject\n.spyproject\n\n# Rope project settings\n.ropeproject\n\n# mkdocs documentation\n/site\n\n# mypy\n.mypy_cache/\n.dmypy.json\ndmypy.json\n\n# Pyre type checker\n.pyre/\n\n# pytype static type analyzer\n.pytype/\n\n# Cython debug symbols\ncython_debug/\n\n# PyCharm\n#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can\n#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore\n#  and can be added to the global gitignore or merged into this file.  For a more nuclear\n#  option (not recommended) you can uncomment the following to ignore the entire idea folder.\n#.idea/\ntemp\ntmp\n\n\n.DS_Store\n\nprivate_example.py\nprivate_example\n\nbrowser_cookies.json\ncookies.json\nAgentHistory.json\ncv_04_24.pdf\nAgentHistoryList.json\n",
    "isBinary": "false"
  },
  "examples/check_appointment.py": {
    "code": "import asyncio\nimport os\n\nimport dotenv\nfrom langchain_openai import ChatOpenAI\nfrom pydantic import BaseModel, SecretStr\n\nfrom browser_use.agent.service import Agent\nfrom browser_use.controller.service import Controller\n\ndotenv.load_dotenv()\n\n\ncontroller = Controller()\n\n\nclass WebpageInfo(BaseModel):\n\tlink: str = 'https://appointment.mfa.gr/en/reservations/aero/ireland-grcon-dub/'\n\n\n@controller.action('Go to the webpage', param_model=WebpageInfo)\ndef go_to_webpage(webpage_info: WebpageInfo):\n\treturn webpage_info.link\n\n\nasync def main():\n\ttask = (\n\t\t'Go to the Greece MFA webpage via the link I provided you.'\n\t\t'Check the visa appointment dates. If there is no available date in this month, check the next month.'\n\t\t'If there is no available date in both months, tell me there is no available date.'\n\t)\n\n\tmodel = ChatOpenAI(model='gpt-4o-mini', api_key=SecretStr(os.getenv('OPENAI_API_KEY', '')))\n\tagent = Agent(task, model, controller=controller, use_vision=True)\n\n\tresult = await agent.run()\n\n\nif __name__ == '__main__':\n\tasyncio.run(main())\n",
    "isBinary": "false"
  },
  "browser_use/controller/registry/views.py": {
    "isBinary": "false",
    "code": "from typing import Callable, Dict, Type\n\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass RegisteredAction(BaseModel):\n\t\"\"\"Model for a registered action\"\"\"\n\n\tname: str\n\tdescription: str\n\tfunction: Callable\n\tparam_model: Type[BaseModel]\n\trequires_browser: bool = False\n\n\tmodel_config = ConfigDict(arbitrary_types_allowed=True)\n\n\tdef prompt_description(self) -> str:\n\t\t\"\"\"Get a description of the action for the prompt\"\"\"\n\t\tskip_keys = ['title']\n\t\ts = f'{self.description}: \\n'\n\t\ts += '{' + str(self.name) + ': '\n\t\ts += str(\n\t\t\t{\n\t\t\t\tk: {sub_k: sub_v for sub_k, sub_v in v.items() if sub_k not in skip_keys}\n\t\t\t\tfor k, v in self.param_model.schema()['properties'].items()\n\t\t\t}\n\t\t)\n\t\ts += '}'\n\t\treturn s\n\n\nclass ActionModel(BaseModel):\n\t\"\"\"Base model for dynamically created action models\"\"\"\n\n\t# this will have all the registered actions, e.g.\n\t# click_element = param_model = ClickElementParams\n\t# done = param_model = None\n\t#\n\tmodel_config = ConfigDict(arbitrary_types_allowed=True)\n\n\tdef get_index(self) -> int | None:\n\t\t\"\"\"Get the index of the action\"\"\"\n\t\t# {'clicked_element': {'index':5}}\n\t\tparams = self.model_dump(exclude_unset=True).values()\n\t\tif not params:\n\t\t\treturn None\n\t\tfor param in params:\n\t\t\tif 'index' in param:\n\t\t\t\treturn param['index']\n\t\treturn None\n\n\tdef set_index(self, index: int):\n\t\t\"\"\"Overwrite the index of the action\"\"\"\n\t\t# Get the action name and params\n\t\taction_data = self.model_dump(exclude_unset=True)\n\t\taction_name = next(iter(action_data.keys()))\n\t\taction_params = getattr(self, action_name)\n\n\t\t# Update the index directly on the model\n\t\tif hasattr(action_params, 'index'):\n\t\t\taction_params.index = index\n\n\nclass ActionRegistry(BaseModel):\n\t\"\"\"Model representing the action registry\"\"\"\n\n\tactions: Dict[str, RegisteredAction] = {}\n\n\tdef get_prompt_description(self) -> str:\n\t\t\"\"\"Get a description of all actions for the prompt\"\"\"\n\t\treturn '\\n'.join([action.prompt_description() for action in self.actions.values()])\n"
  },
  "LICENSE": {
    "code": "MIT License\n\nCopyright (c) 2024 Gregor Zunic\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
    "isBinary": "false"
  },
  "pyproject.toml": {
    "code": "[project]\nname = \"browser-use\"\ndescription = \"Make websites accessible for AI agents\"\nauthors = [\n    { name = \"Gregor Zunic\" }\n]\nversion = \"0.1.17\"\nreadme = \"README.md\"\nrequires-python = \">=3.11\"\nclassifiers = [\n    \"Programming Language :: Python :: 3\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Operating System :: OS Independent\",\n]\ndependencies = [\n    \"MainContentExtractor>=0.0.4\",\n    \"beautifulsoup4>=4.12.3\",\n    \"httpx==0.27.2\",\n    \"langchain>=0.3.9\",\n    \"langchain-openai>=0.2.10\",\n    \"langchain-anthropic>=0.3.0\",\n    \"langchain-fireworks>=0.2.5\",\n    \"pydantic>=2.10.2\",\n    \"python-dotenv>=1.0.1\",\n    \"requests>=2.32.3\",\n    \"posthog>=3.7.4\",\n    \"playwright>=1.49.0\"\n]\n\n[project.optional-dependencies]\ndev = [\n    \"tokencost>=0.1.16\",\n    \"hatch>=1.13.0\",\n    \"build>=1.2.2\",\n    \"pytest>=8.3.3\",\n    \"pytest-asyncio>=0.24.0\"\n]\n\n[tool.ruff]\nline-length = 100\n\n[tool.ruff.format]\nquote-style = \"single\"\nindent-style = \"tab\"\ndocstring-code-format = true\n\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"",
    "isBinary": "false"
  },
  ".env.example": {
    "isBinary": "false",
    "code": "OPENAI_API_KEY=\nANTHROPIC_API_KEY=\n\n# Set to false to disable anonymized telemetry\nANONYMIZED_TELEMETRY=true\n\n# LogLevel: Set to debug to enable verbose logging, set to result to get results only. Available: result | debug | info\nBROWSER_USE_LOGGING_LEVEL=info"
  },
  "examples/web_voyager_agent.py": {
    "code": "import os\nimport sys\n\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nimport asyncio\nimport os\n\nfrom langchain_openai import AzureChatOpenAI\nfrom pydantic import SecretStr\n\nfrom browser_use.agent.service import Agent\nfrom browser_use.browser.browser import Browser, BrowserConfig, BrowserContextConfig\n\nbrowser = Browser(\n\tconfig=BrowserConfig(\n\t\theadless=False,  # This is True in production\n\t\tdisable_security=True,\n\t\tnew_context_config=BrowserContextConfig(\n\t\t\tdisable_security=True,\n\t\t\tminimum_wait_page_load_time=1,  # 3 on prod\n\t\t\tmaximum_wait_page_load_time=10,  # 20 on prod\n\t\t\t# no_viewport=True,\n\t\t\tbrowser_window_size={\n\t\t\t\t'width': 1280,\n\t\t\t\t'height': 1100,\n\t\t\t},\n\t\t\t# trace_path='./tmp/web_voyager_agent',\n\t\t),\n\t)\n)\nllm = AzureChatOpenAI(\n\tmodel='gpt-4o',\n\tapi_version='2024-10-21',\n\tazure_endpoint=os.getenv('AZURE_OPENAI_ENDPOINT', ''),\n\tapi_key=SecretStr(os.getenv('AZURE_OPENAI_KEY', '')),\n)\n\n# TASK = \"\"\"\n# Find the lowest-priced one-way flight from Cairo to Montreal on February 21, 2025, including the total travel time and number of stops. on https://www.google.com/travel/flights/\n# \"\"\"\n# TASK = \"\"\"\n# Browse Coursera, which universities offer Master of Advanced Study in Engineering degrees? Tell me what is the latest application deadline for this degree? on https://www.coursera.org/\"\"\"\nTASK = \"\"\"\nFind and book a hotel in Paris with suitable accommodations for a family of four (two adults and two children) offering free cancellation for the dates of February 14-21, 2025. on https://www.booking.com/\n\"\"\"\n\n\nasync def main():\n\tagent = Agent(\n\t\ttask=TASK,\n\t\tllm=llm,\n\t\tbrowser=browser,\n\t\tvalidate_output=True,\n\t)\n\thistory = await agent.run(max_steps=50)\n\thistory.save_to_file('./tmp/history.json')\n\n\nif __name__ == '__main__':\n\tasyncio.run(main())\n",
    "isBinary": "false"
  },
  "browser_use/__init__.py": {
    "isBinary": "false",
    "code": "from browser_use.logging_config import setup_logging\n\nsetup_logging()\n\nfrom browser_use.agent.prompts import SystemPrompt as SystemPrompt\nfrom browser_use.agent.service import Agent as Agent\nfrom browser_use.agent.views import ActionModel as ActionModel\nfrom browser_use.agent.views import ActionResult as ActionResult\nfrom browser_use.agent.views import AgentHistoryList as AgentHistoryList\nfrom browser_use.browser.browser import Browser as Browser\nfrom browser_use.browser.browser import BrowserConfig as BrowserConfig\nfrom browser_use.controller.service import Controller as Controller\nfrom browser_use.dom.service import DomService as DomService\n\n__all__ = [\n\t'Agent',\n\t'Browser',\n\t'BrowserConfig',\n\t'Controller',\n\t'DomService',\n\t'SystemPrompt',\n\t'ActionResult',\n\t'ActionModel',\n\t'AgentHistoryList',\n]\n"
  },
  "examples/multi-tab_handling.py": {
    "code": "\"\"\"\nSimple try of the agent.\n\n@dev You need to add OPENAI_API_KEY to your environment variables.\n\"\"\"\n\nimport os\nimport sys\n\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nimport asyncio\n\nfrom langchain_openai import ChatOpenAI\n\nfrom browser_use import Agent\n\n# video: https://preview.screen.studio/share/clenCmS6\nllm = ChatOpenAI(model='gpt-4o')\nagent = Agent(\n\ttask='open 3 tabs with elon musk, trump, and steve jobs, then go back to the first and stop',\n\tllm=llm,\n)\n\n\nasync def main():\n\tawait agent.run()\n\n\nasyncio.run(main())\n",
    "isBinary": "false"
  },
  "browser_use/controller/registry/service.py": {
    "isBinary": "false",
    "code": "import asyncio\nfrom inspect import iscoroutinefunction, signature\nfrom typing import Any, Callable, Optional, Type\n\nfrom pydantic import BaseModel, create_model\n\nfrom browser_use.browser.context import BrowserContext\nfrom browser_use.controller.registry.views import (\n\tActionModel,\n\tActionRegistry,\n\tRegisteredAction,\n)\nfrom browser_use.telemetry.service import ProductTelemetry\nfrom browser_use.telemetry.views import (\n\tControllerRegisteredFunctionsTelemetryEvent,\n\tRegisteredFunction,\n)\n\n\nclass Registry:\n\t\"\"\"Service for registering and managing actions\"\"\"\n\n\tdef __init__(self):\n\t\tself.registry = ActionRegistry()\n\t\tself.telemetry = ProductTelemetry()\n\n\tdef _create_param_model(self, function: Callable) -> Type[BaseModel]:\n\t\t\"\"\"Creates a Pydantic model from function signature\"\"\"\n\t\tsig = signature(function)\n\t\tparams = {\n\t\t\tname: (param.annotation, ... if param.default == param.empty else param.default)\n\t\t\tfor name, param in sig.parameters.items()\n\t\t\tif name != 'browser'\n\t\t}\n\t\t# TODO: make the types here work\n\t\treturn create_model(\n\t\t\tf'{function.__name__}Params',\n\t\t\t__base__=ActionModel,\n\t\t\t**params,  # type: ignore\n\t\t)\n\n\tdef action(\n\t\tself,\n\t\tdescription: str,\n\t\tparam_model: Optional[Type[BaseModel]] = None,\n\t\trequires_browser: bool = False,\n\t):\n\t\t\"\"\"Decorator for registering actions\"\"\"\n\n\t\tdef decorator(func: Callable):\n\t\t\t# Create param model from function if not provided\n\t\t\tactual_param_model = param_model or self._create_param_model(func)\n\n\t\t\t# Wrap sync functions to make them async\n\t\t\tif not iscoroutinefunction(func):\n\n\t\t\t\tasync def async_wrapper(*args, **kwargs):\n\t\t\t\t\treturn await asyncio.to_thread(func, *args, **kwargs)\n\n\t\t\t\t# Copy the signature and other metadata from the original function\n\t\t\t\tasync_wrapper.__signature__ = signature(func)\n\t\t\t\tasync_wrapper.__name__ = func.__name__\n\t\t\t\tasync_wrapper.__annotations__ = func.__annotations__\n\t\t\t\twrapped_func = async_wrapper\n\t\t\telse:\n\t\t\t\twrapped_func = func\n\n\t\t\taction = RegisteredAction(\n\t\t\t\tname=func.__name__,\n\t\t\t\tdescription=description,\n\t\t\t\tfunction=wrapped_func,\n\t\t\t\tparam_model=actual_param_model,\n\t\t\t\trequires_browser=requires_browser,\n\t\t\t)\n\t\t\tself.registry.actions[func.__name__] = action\n\t\t\treturn func\n\n\t\treturn decorator\n\n\tasync def execute_action(\n\t\tself, action_name: str, params: dict, browser: Optional[BrowserContext] = None\n\t) -> Any:\n\t\t\"\"\"Execute a registered action\"\"\"\n\t\tif action_name not in self.registry.actions:\n\t\t\traise ValueError(f'Action {action_name} not found')\n\n\t\taction = self.registry.actions[action_name]\n\t\ttry:\n\t\t\t# Create the validated Pydantic model\n\t\t\tvalidated_params = action.param_model(**params)\n\n\t\t\t# Check if the first parameter is a Pydantic model\n\t\t\tsig = signature(action.function)\n\t\t\tparameters = list(sig.parameters.values())\n\t\t\tis_pydantic = parameters and issubclass(parameters[0].annotation, BaseModel)\n\n\t\t\t# Prepare arguments based on parameter type\n\t\t\tif action.requires_browser:\n\t\t\t\tif not browser:\n\t\t\t\t\traise ValueError(\n\t\t\t\t\t\tf'Action {action_name} requires browser but none provided. This has to be used in combination of `requires_browser=True` when registering the action.'\n\t\t\t\t\t)\n\t\t\t\tif is_pydantic:\n\t\t\t\t\treturn await action.function(validated_params, browser=browser)\n\t\t\t\treturn await action.function(**validated_params.model_dump(), browser=browser)\n\n\t\t\tif is_pydantic:\n\t\t\t\treturn await action.function(validated_params)\n\t\t\treturn await action.function(**validated_params.model_dump())\n\n\t\texcept Exception as e:\n\t\t\traise RuntimeError(f'Error executing action {action_name}: {str(e)}') from e\n\n\tdef create_action_model(self) -> Type[ActionModel]:\n\t\t\"\"\"Creates a Pydantic model from registered actions\"\"\"\n\t\tfields = {\n\t\t\tname: (Optional[action.param_model], None)\n\t\t\tfor name, action in self.registry.actions.items()\n\t\t}\n\n\t\tself.telemetry.capture(\n\t\t\tControllerRegisteredFunctionsTelemetryEvent(\n\t\t\t\tregistered_functions=[\n\t\t\t\t\tRegisteredFunction(name=name, params=action.param_model.model_json_schema())\n\t\t\t\t\tfor name, action in self.registry.actions.items()\n\t\t\t\t]\n\t\t\t)\n\t\t)\n\n\t\treturn create_model('ActionModel', __base__=ActionModel, **fields)  # type:ignore\n\n\tdef get_prompt_description(self) -> str:\n\t\t\"\"\"Get a description of all actions for the prompt\"\"\"\n\t\treturn self.registry.get_prompt_description()\n"
  },
  "examples/amazon_search.py": {
    "isBinary": "false",
    "code": "\"\"\"\nSimple try of the agent.\n\n@dev You need to add OPENAI_API_KEY to your environment variables.\n\"\"\"\n\nimport os\nimport sys\n\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nimport asyncio\n\nfrom langchain_openai import ChatOpenAI\n\nfrom browser_use import Agent\n\n# video: https://preview.screen.studio/share/70xBqZyN\nllm = ChatOpenAI(model='gpt-4o')\nagent = Agent(\n\ttask='Go to amazon.com, search for laptop, sort by best rating, and give me the price of the first result',\n\tllm=llm,\n)\n\n\nasync def main():\n\tawait agent.run()\n\n\nasyncio.run(main())\n"
  },
  "browser_use/controller/service.py": {
    "isBinary": "false",
    "code": "import asyncio\nimport logging\n\nfrom main_content_extractor import MainContentExtractor\nfrom playwright.async_api import Page\n\nfrom browser_use.agent.views import ActionModel, ActionResult\nfrom browser_use.browser.context import BrowserContext\nfrom browser_use.controller.registry.service import Registry\nfrom browser_use.controller.views import (\n\tClickElementAction,\n\tDoneAction,\n\tExtractPageContentAction,\n\tGoToUrlAction,\n\tInputTextAction,\n\tOpenTabAction,\n\tScrollAction,\n\tSearchGoogleAction,\n\tSendKeysAction,\n\tSwitchTabAction,\n)\nfrom browser_use.utils import time_execution_async, time_execution_sync\n\nlogger = logging.getLogger(__name__)\n\n\nclass Controller:\n\tdef __init__(\n\t\tself,\n\t):\n\t\tself.registry = Registry()\n\t\tself._register_default_actions()\n\n\tdef _register_default_actions(self):\n\t\t\"\"\"Register all default browser actions\"\"\"\n\n\t\t# Basic Navigation Actions\n\t\t@self.registry.action(\n\t\t\t'Search Google in the current tab',\n\t\t\tparam_model=SearchGoogleAction,\n\t\t\trequires_browser=True,\n\t\t)\n\t\tasync def search_google(params: SearchGoogleAction, browser: BrowserContext):\n\t\t\tpage = await browser.get_current_page()\n\t\t\tawait page.goto(f'https://www.google.com/search?q={params.query}')\n\t\t\tawait page.wait_for_load_state()\n\t\t\tmsg = f'  Searched for \"{params.query}\" in Google'\n\t\t\tlogger.info(msg)\n\t\t\treturn ActionResult(extracted_content=msg, include_in_memory=True)\n\n\t\t@self.registry.action(\n\t\t\t'Navigate to URL in the current tab', param_model=GoToUrlAction, requires_browser=True\n\t\t)\n\t\tasync def go_to_url(params: GoToUrlAction, browser: BrowserContext):\n\t\t\tpage = await browser.get_current_page()\n\t\t\tawait page.goto(params.url)\n\t\t\tawait page.wait_for_load_state()\n\t\t\tmsg = f'  Navigated to {params.url}'\n\t\t\tlogger.info(msg)\n\t\t\treturn ActionResult(extracted_content=msg, include_in_memory=True)\n\n\t\t@self.registry.action('Go back', requires_browser=True)\n\t\tasync def go_back(browser: BrowserContext):\n\t\t\tpage = await browser.get_current_page()\n\t\t\tawait page.go_back()\n\t\t\tawait page.wait_for_load_state()\n\t\t\tmsg = '  Navigated back'\n\t\t\tlogger.info(msg)\n\t\t\treturn ActionResult(extracted_content=msg, include_in_memory=True)\n\n\t\t# Element Interaction Actions\n\t\t@self.registry.action(\n\t\t\t'Click element', param_model=ClickElementAction, requires_browser=True\n\t\t)\n\t\tasync def click_element(params: ClickElementAction, browser: BrowserContext):\n\t\t\tsession = await browser.get_session()\n\t\t\tstate = session.cached_state\n\n\t\t\tif params.index not in state.selector_map:\n\t\t\t\traise Exception(\n\t\t\t\t\tf'Element with index {params.index} does not exist - retry or use alternative actions'\n\t\t\t\t)\n\n\t\t\telement_node = state.selector_map[params.index]\n\t\t\tinitial_pages = len(session.context.pages)\n\n\t\t\t# if element has file uploader then dont click\n\t\t\tif await browser.is_file_uploader(element_node):\n\t\t\t\tmsg = f'Index {params.index} - has an element which opens file upload dialog. To upload files please use a specific function to upload files '\n\t\t\t\tlogger.info(msg)\n\t\t\t\treturn ActionResult(extracted_content=msg, include_in_memory=True)\n\n\t\t\tmsg = None\n\n\t\t\ttry:\n\t\t\t\tawait browser._click_element_node(element_node)\n\t\t\t\tmsg = f'  Clicked index {params.index}'\n\t\t\t\tlogger.info(msg)\n\t\t\t\tlogger.debug(f'Element xpath: {element_node.xpath}')\n\t\t\t\tif len(session.context.pages) > initial_pages:\n\t\t\t\t\tnew_tab_msg = 'New tab opened - switching to it'\n\t\t\t\t\tmsg += f' - {new_tab_msg}'\n\t\t\t\t\tlogger.info(new_tab_msg)\n\t\t\t\t\tawait browser.switch_to_tab(-1)\n\t\t\t\treturn ActionResult(extracted_content=msg, include_in_memory=True)\n\t\t\texcept Exception as e:\n\t\t\t\tlogger.warning(\n\t\t\t\t\tf'Element no longer available with index {params.index} - most likely the page changed'\n\t\t\t\t)\n\t\t\t\treturn ActionResult(error=str(e))\n\n\t\t@self.registry.action(\n\t\t\t'Input text into a input interactive element',\n\t\t\tparam_model=InputTextAction,\n\t\t\trequires_browser=True,\n\t\t)\n\t\tasync def input_text(params: InputTextAction, browser: BrowserContext):\n\t\t\tsession = await browser.get_session()\n\t\t\tstate = session.cached_state\n\n\t\t\tif params.index not in state.selector_map:\n\t\t\t\traise Exception(\n\t\t\t\t\tf'Element index {params.index} does not exist - retry or use alternative actions'\n\t\t\t\t)\n\n\t\t\telement_node = state.selector_map[params.index]\n\t\t\tawait browser._input_text_element_node(element_node, params.text)\n\t\t\tmsg = f'  Input \"{params.text}\" into index {params.index}'\n\t\t\tlogger.info(msg)\n\t\t\tlogger.debug(f'Element xpath: {element_node.xpath}')\n\t\t\treturn ActionResult(extracted_content=msg, include_in_memory=True)\n\n\t\t# Tab Management Actions\n\t\t@self.registry.action('Switch tab', param_model=SwitchTabAction, requires_browser=True)\n\t\tasync def switch_tab(params: SwitchTabAction, browser: BrowserContext):\n\t\t\tawait browser.switch_to_tab(params.page_id)\n\t\t\t# Wait for tab to be ready\n\t\t\tpage = await browser.get_current_page()\n\t\t\tawait page.wait_for_load_state()\n\t\t\tmsg = f'  Switched to tab {params.page_id}'\n\t\t\tlogger.info(msg)\n\t\t\treturn ActionResult(extracted_content=msg, include_in_memory=True)\n\n\t\t@self.registry.action(\n\t\t\t'Open url in new tab', param_model=OpenTabAction, requires_browser=True\n\t\t)\n\t\tasync def open_tab(params: OpenTabAction, browser: BrowserContext):\n\t\t\tawait browser.create_new_tab(params.url)\n\t\t\tmsg = f'  Opened new tab with {params.url}'\n\t\t\tlogger.info(msg)\n\t\t\treturn ActionResult(extracted_content=msg, include_in_memory=True)\n\n\t\t# Content Actions\n\t\t@self.registry.action(\n\t\t\t'Extract page content to get the text or markdown ',\n\t\t\tparam_model=ExtractPageContentAction,\n\t\t\trequires_browser=True,\n\t\t)\n\t\tasync def extract_content(params: ExtractPageContentAction, browser: BrowserContext):\n\t\t\tpage = await browser.get_current_page()\n\n\t\t\tcontent = MainContentExtractor.extract(  # type: ignore\n\t\t\t\thtml=await page.content(),\n\t\t\t\toutput_format=params.value,\n\t\t\t)\n\t\t\tmsg = f'  Extracted page content\\n: {content}\\n'\n\t\t\tlogger.info(msg)\n\t\t\treturn ActionResult(extracted_content=msg)\n\n\t\t@self.registry.action('Complete task', param_model=DoneAction)\n\t\tasync def done(params: DoneAction):\n\t\t\treturn ActionResult(is_done=True, extracted_content=params.text)\n\n\t\t@self.registry.action(\n\t\t\t'Scroll down the page by pixel amount - if no amount is specified, scroll down one page',\n\t\t\tparam_model=ScrollAction,\n\t\t\trequires_browser=True,\n\t\t)\n\t\tasync def scroll_down(params: ScrollAction, browser: BrowserContext):\n\t\t\tpage = await browser.get_current_page()\n\t\t\tif params.amount is not None:\n\t\t\t\tawait page.evaluate(f'window.scrollBy(0, {params.amount});')\n\t\t\telse:\n\t\t\t\tawait page.keyboard.press('PageDown')\n\n\t\t\tamount = f'{params.amount} pixels' if params.amount is not None else 'one page'\n\t\t\tmsg = f'  Scrolled down the page by {amount}'\n\t\t\tlogger.info(msg)\n\t\t\treturn ActionResult(\n\t\t\t\textracted_content=msg,\n\t\t\t\tinclude_in_memory=True,\n\t\t\t)\n\n\t\t# scroll up\n\t\t@self.registry.action(\n\t\t\t'Scroll up the page by pixel amount - if no amount is specified, scroll up one page',\n\t\t\tparam_model=ScrollAction,\n\t\t\trequires_browser=True,\n\t\t)\n\t\tasync def scroll_up(params: ScrollAction, browser: BrowserContext):\n\t\t\tpage = await browser.get_current_page()\n\t\t\tif params.amount is not None:\n\t\t\t\tawait page.evaluate(f'window.scrollBy(0, -{params.amount});')\n\t\t\telse:\n\t\t\t\tawait page.keyboard.press('PageUp')\n\n\t\t\tamount = f'{params.amount} pixels' if params.amount is not None else 'one page'\n\t\t\tmsg = f'  Scrolled up the page by {amount}'\n\t\t\tlogger.info(msg)\n\t\t\treturn ActionResult(\n\t\t\t\textracted_content=msg,\n\t\t\t\tinclude_in_memory=True,\n\t\t\t)\n\n\t\t# send keys\n\t\t@self.registry.action(\n\t\t\t'Send strings of special keys like Backspace, Insert, PageDown, Delete, Enter, Shortcuts such as `Control+o`, `Control+Shift+T` are supported as well. This gets used in keyboard.press. Be aware of different operating systems and their shortcuts',\n\t\t\tparam_model=SendKeysAction,\n\t\t\trequires_browser=True,\n\t\t)\n\t\tasync def send_keys(params: SendKeysAction, browser: BrowserContext):\n\t\t\tpage = await browser.get_current_page()\n\n\t\t\tawait page.keyboard.press(params.keys)\n\t\t\tmsg = f'  Sent keys: {params.keys}'\n\t\t\tlogger.info(msg)\n\t\t\treturn ActionResult(extracted_content=msg, include_in_memory=True)\n\n\t\t@self.registry.action(\n\t\t\tdescription='If you dont find something which you want to interact with, scroll to it',\n\t\t\trequires_browser=True,\n\t\t)\n\t\tasync def scroll_to_text(text: str, browser: BrowserContext):  # type: ignore\n\t\t\tpage = await browser.get_current_page()\n\t\t\ttry:\n\t\t\t\t# Try different locator strategies\n\t\t\t\tlocators = [\n\t\t\t\t\tpage.get_by_text(text, exact=False),\n\t\t\t\t\tpage.locator(f'text={text}'),\n\t\t\t\t\tpage.locator(f\"//*[contains(text(), '{text}')]\"),\n\t\t\t\t]\n\n\t\t\t\tfor locator in locators:\n\t\t\t\t\ttry:\n\t\t\t\t\t\t# First check if element exists and is visible\n\t\t\t\t\t\tif await locator.count() > 0 and await locator.first.is_visible():\n\t\t\t\t\t\t\tawait locator.first.scroll_into_view_if_needed()\n\t\t\t\t\t\t\tawait asyncio.sleep(0.5)  # Wait for scroll to complete\n\t\t\t\t\t\t\tmsg = f'  Scrolled to text: {text}'\n\t\t\t\t\t\t\tlogger.info(msg)\n\t\t\t\t\t\t\treturn ActionResult(extracted_content=msg, include_in_memory=True)\n\t\t\t\t\texcept Exception as e:\n\t\t\t\t\t\tlogger.debug(f'Locator attempt failed: {str(e)}')\n\t\t\t\t\t\tcontinue\n\n\t\t\t\tmsg = f\"Text '{text}' not found or not visible on page\"\n\t\t\t\tlogger.info(msg)\n\t\t\t\treturn ActionResult(extracted_content=msg, include_in_memory=True)\n\n\t\t\texcept Exception as e:\n\t\t\t\tmsg = f\"Failed to scroll to text '{text}': {str(e)}\"\n\t\t\t\tlogger.error(msg)\n\t\t\t\treturn ActionResult(error=msg, include_in_memory=True)\n\n\t\t@self.registry.action(\n\t\t\tdescription='Get all options from a native dropdown',\n\t\t\trequires_browser=True,\n\t\t)\n\t\tasync def get_dropdown_options(index: int, browser: BrowserContext) -> ActionResult:\n\t\t\t\"\"\"Get all options from a native dropdown\"\"\"\n\t\t\tpage = await browser.get_current_page()\n\t\t\tselector_map = await browser.get_selector_map()\n\t\t\tdom_element = selector_map[index]\n\n\t\t\ttry:\n\t\t\t\t# Frame-aware approach since we know it works\n\t\t\t\tall_options = []\n\t\t\t\tframe_index = 0\n\n\t\t\t\tfor frame in page.frames:\n\t\t\t\t\ttry:\n\t\t\t\t\t\toptions = await frame.evaluate(\n\t\t\t\t\t\t\t\"\"\"\n\t\t\t\t\t\t\t(xpath) => {\n\t\t\t\t\t\t\t\tconst select = document.evaluate(xpath, document, null,\n\t\t\t\t\t\t\t\t\tXPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n\t\t\t\t\t\t\t\tif (!select) return null;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\toptions: Array.from(select.options).map(opt => ({\n\t\t\t\t\t\t\t\t\t\ttext: opt.text.trim(),\n\t\t\t\t\t\t\t\t\t\tvalue: opt.value,\n\t\t\t\t\t\t\t\t\t\tindex: opt.index\n\t\t\t\t\t\t\t\t\t})),\n\t\t\t\t\t\t\t\t\tid: select.id,\n\t\t\t\t\t\t\t\t\tname: select.name\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\"\"\",\n\t\t\t\t\t\t\tdom_element.xpath,\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tif options:\n\t\t\t\t\t\t\tlogger.debug(f'Found dropdown in frame {frame_index}')\n\t\t\t\t\t\t\tlogger.debug(f\"Dropdown ID: {options['id']}, Name: {options['name']}\")\n\n\t\t\t\t\t\t\tformatted_options = []\n\t\t\t\t\t\t\tfor opt in options['options']:\n\t\t\t\t\t\t\t\tformatted_options.append(\n\t\t\t\t\t\t\t\t\tf\"{opt['index']}: {opt['text']} (value={opt['value']})\"\n\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\tall_options.extend(formatted_options)\n\n\t\t\t\t\texcept Exception as frame_e:\n\t\t\t\t\t\tlogger.debug(f'Frame {frame_index} evaluation failed: {str(frame_e)}')\n\n\t\t\t\t\tframe_index += 1\n\n\t\t\t\tif all_options:\n\t\t\t\t\tmsg = '\\n'.join(all_options)\n\t\t\t\t\tlogger.info(msg)\n\t\t\t\t\treturn ActionResult(extracted_content=msg, include_in_memory=True)\n\t\t\t\telse:\n\t\t\t\t\tmsg = 'No options found in any frame for dropdown'\n\t\t\t\t\tlogger.info(msg)\n\t\t\t\t\treturn ActionResult(extracted_content=msg, include_in_memory=True)\n\n\t\t\texcept Exception as e:\n\t\t\t\tlogger.error(f'Failed to get dropdown options: {str(e)}')\n\t\t\t\tmsg = f'Error getting options: {str(e)}'\n\t\t\t\tlogger.info(msg)\n\t\t\t\treturn ActionResult(extracted_content=msg, include_in_memory=True)\n\n\t\t@self.registry.action(\n\t\t\tdescription='Select dropdown option for interactive element index by the text of the option you want to select',\n\t\t\trequires_browser=True,\n\t\t)\n\t\tasync def select_dropdown_option(\n\t\t\tindex: int,\n\t\t\ttext: str,\n\t\t\tbrowser: BrowserContext,\n\t\t) -> ActionResult:\n\t\t\t\"\"\"Select dropdown option by the text of the option you want to select\"\"\"\n\t\t\tpage = await browser.get_current_page()\n\t\t\tselector_map = await browser.get_selector_map()\n\t\t\tdom_element = selector_map[index]\n\n\t\t\t# Validate that we're working with a select element\n\t\t\tif dom_element.tag_name != 'select':\n\t\t\t\tlogger.error(\n\t\t\t\t\tf'Element is not a select! Tag: {dom_element.tag_name}, Attributes: {dom_element.attributes}'\n\t\t\t\t)\n\t\t\t\tmsg = f'Cannot select option: Element with index {index} is a {dom_element.tag_name}, not a select'\n\t\t\t\treturn ActionResult(extracted_content=msg, include_in_memory=True)\n\n\t\t\tlogger.debug(f\"Attempting to select '{text}' using xpath: {dom_element.xpath}\")\n\t\t\tlogger.debug(f'Element attributes: {dom_element.attributes}')\n\t\t\tlogger.debug(f'Element tag: {dom_element.tag_name}')\n\n\t\t\ttry:\n\t\t\t\tframe_index = 0\n\t\t\t\tfor frame in page.frames:\n\t\t\t\t\ttry:\n\t\t\t\t\t\tlogger.debug(f'Trying frame {frame_index} URL: {frame.url}')\n\n\t\t\t\t\t\t# First verify we can find the dropdown in this frame\n\t\t\t\t\t\tfind_dropdown_js = \"\"\"\n\t\t\t\t\t\t\t(xpath) => {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tconst select = document.evaluate(xpath, document, null,\n\t\t\t\t\t\t\t\t\t\tXPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n\t\t\t\t\t\t\t\t\tif (!select) return null;\n\t\t\t\t\t\t\t\t\tif (select.tagName.toLowerCase() !== 'select') {\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\terror: `Found element but it's a ${select.tagName}, not a SELECT`,\n\t\t\t\t\t\t\t\t\t\t\tfound: false\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\tid: select.id,\n\t\t\t\t\t\t\t\t\t\tname: select.name,\n\t\t\t\t\t\t\t\t\t\tfound: true,\n\t\t\t\t\t\t\t\t\t\ttagName: select.tagName,\n\t\t\t\t\t\t\t\t\t\toptionCount: select.options.length,\n\t\t\t\t\t\t\t\t\t\tcurrentValue: select.value,\n\t\t\t\t\t\t\t\t\t\tavailableOptions: Array.from(select.options).map(o => o.text.trim())\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\treturn {error: e.toString(), found: false};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\"\"\"\n\n\t\t\t\t\t\tdropdown_info = await frame.evaluate(find_dropdown_js, dom_element.xpath)\n\n\t\t\t\t\t\tif dropdown_info:\n\t\t\t\t\t\t\tif not dropdown_info.get('found'):\n\t\t\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t\t\tf\"Frame {frame_index} error: {dropdown_info.get('error')}\"\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\t\tlogger.debug(f'Found dropdown in frame {frame_index}: {dropdown_info}')\n\n\t\t\t\t\t\t\t# Rest of the selection code remains the same...\n\t\t\t\t\t\t\tselect_option_js = \"\"\"\n\t\t\t\t\t\t\t\t(params) => {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tconst select = document.evaluate(params.xpath, document, null,\n\t\t\t\t\t\t\t\t\t\t\tXPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n\t\t\t\t\t\t\t\t\t\tif (!select || select.tagName.toLowerCase() !== 'select') {\n\t\t\t\t\t\t\t\t\t\t\treturn {success: false, error: 'Select not found or invalid element type'};\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tconst option = Array.from(select.options)\n\t\t\t\t\t\t\t\t\t\t\t.find(opt => opt.text.trim() === params.text);\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif (!option) {\n\t\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\t\tsuccess: false, \n\t\t\t\t\t\t\t\t\t\t\t\terror: 'Option not found',\n\t\t\t\t\t\t\t\t\t\t\t\tavailableOptions: Array.from(select.options).map(o => o.text.trim())\n\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tselect.value = option.value;\n\t\t\t\t\t\t\t\t\t\tselect.dispatchEvent(new Event('change'));\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\tsuccess: true, \n\t\t\t\t\t\t\t\t\t\t\tselectedValue: option.value,\n\t\t\t\t\t\t\t\t\t\t\tselectedText: option.text.trim()\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\t\treturn {success: false, error: e.toString()};\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\"\"\"\n\n\t\t\t\t\t\t\tparams = {'xpath': dom_element.xpath, 'text': text}\n\n\t\t\t\t\t\t\tresult = await frame.evaluate(select_option_js, params)\n\t\t\t\t\t\t\tlogger.debug(f'Selection result: {result}')\n\n\t\t\t\t\t\t\tif result.get('success'):\n\t\t\t\t\t\t\t\tmsg = (\n\t\t\t\t\t\t\t\t\tf\"Selected option '{text}' (value={result.get('selectedValue')}\"\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tlogger.info(msg + f' in frame {frame_index}')\n\t\t\t\t\t\t\t\treturn ActionResult(extracted_content=msg, include_in_memory=True)\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tlogger.error(f\"Selection failed: {result.get('error')}\")\n\t\t\t\t\t\t\t\tif 'availableOptions' in result:\n\t\t\t\t\t\t\t\t\tlogger.error(f\"Available options: {result['availableOptions']}\")\n\n\t\t\t\t\texcept Exception as frame_e:\n\t\t\t\t\t\tlogger.error(f'Frame {frame_index} attempt failed: {str(frame_e)}')\n\t\t\t\t\t\tlogger.error(f'Frame type: {type(frame)}')\n\t\t\t\t\t\tlogger.error(f'Frame URL: {frame.url}')\n\n\t\t\t\t\tframe_index += 1\n\n\t\t\t\tmsg = f\"Could not select option '{text}' in any frame\"\n\t\t\t\tlogger.info(msg)\n\t\t\t\treturn ActionResult(extracted_content=msg, include_in_memory=True)\n\n\t\t\texcept Exception as e:\n\t\t\t\tmsg = f'Selection failed: {str(e)}'\n\t\t\t\tlogger.error(msg)\n\t\t\t\treturn ActionResult(error=msg, include_in_memory=True)\n\n\tdef action(self, description: str, **kwargs):\n\t\t\"\"\"Decorator for registering custom actions\n\n\t\t@param description: Describe the LLM what the function does (better description == better function calling)\n\t\t\"\"\"\n\t\treturn self.registry.action(description, **kwargs)\n\n\t@time_execution_async('--multi-act')\n\tasync def multi_act(\n\t\tself, actions: list[ActionModel], browser_context: BrowserContext\n\t) -> list[ActionResult]:\n\t\t\"\"\"Execute multiple actions\"\"\"\n\t\tresults = []\n\n\t\tsession = await browser_context.get_session()\n\t\tcached_selector_map = session.cached_state.selector_map\n\t\tcached_path_hashes = set(e.hash.branch_path_hash for e in cached_selector_map.values())\n\t\tawait browser_context.remove_highlights()\n\n\t\tfor i, action in enumerate(actions):\n\t\t\tif action.get_index() is not None and i != 0:\n\t\t\t\tnew_state = await browser_context.get_state()\n\t\t\t\tnew_path_hashes = set(\n\t\t\t\t\te.hash.branch_path_hash for e in new_state.selector_map.values()\n\t\t\t\t)\n\t\t\t\tif not new_path_hashes.issubset(cached_path_hashes):\n\t\t\t\t\t# next action requires index but there are new elements on the page\n\t\t\t\t\tlogger.info(f'Something new appeared after action {i } / {len(actions)}')\n\t\t\t\t\tbreak\n\n\t\t\tresults.append(await self.act(action, browser_context))\n\n\t\t\tlogger.debug(f'Executed action {i + 1} / {len(actions)}')\n\t\t\tif results[-1].is_done or results[-1].error or i == len(actions) - 1:\n\t\t\t\tbreak\n\n\t\t\tawait asyncio.sleep(browser_context.config.wait_between_actions)\n\t\t\t# hash all elements. if it is a subset of cached_state its fine - else break (new elements on page)\n\n\t\treturn results\n\n\t@time_execution_sync('--act')\n\tasync def act(self, action: ActionModel, browser_context: BrowserContext) -> ActionResult:\n\t\t\"\"\"Execute an action\"\"\"\n\t\ttry:\n\t\t\tfor action_name, params in action.model_dump(exclude_unset=True).items():\n\t\t\t\tif params is not None:\n\t\t\t\t\t# remove highlights\n\t\t\t\t\tresult = await self.registry.execute_action(\n\t\t\t\t\t\taction_name, params, browser=browser_context\n\t\t\t\t\t)\n\t\t\t\t\tif isinstance(result, str):\n\t\t\t\t\t\treturn ActionResult(extracted_content=result)\n\t\t\t\t\telif isinstance(result, ActionResult):\n\t\t\t\t\t\treturn result\n\t\t\t\t\telif result is None:\n\t\t\t\t\t\treturn ActionResult()\n\t\t\t\t\telse:\n\t\t\t\t\t\traise ValueError(f'Invalid action result type: {type(result)} of {result}')\n\t\t\treturn ActionResult()\n\t\texcept Exception as e:\n\t\t\traise e\n"
  },
  "browser_use/agent/message_manager/views.py": {
    "code": "from __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom langchain_core.messages import AIMessage, BaseMessage, HumanMessage, SystemMessage\nfrom pydantic import BaseModel, Field\n\n\nclass MessageMetadata(BaseModel):\n\t\"\"\"Metadata for a message including token counts\"\"\"\n\n\tinput_tokens: int = 0\n\n\nclass ManagedMessage(BaseModel):\n\t\"\"\"A message with its metadata\"\"\"\n\n\tmessage: BaseMessage\n\tmetadata: MessageMetadata = Field(default_factory=MessageMetadata)\n\n\nclass MessageHistory(BaseModel):\n\t\"\"\"Container for message history with metadata\"\"\"\n\n\tmessages: List[ManagedMessage] = Field(default_factory=list)\n\ttotal_tokens: int = 0\n\n\tdef add_message(self, message: BaseMessage, metadata: MessageMetadata) -> None:\n\t\t\"\"\"Add a message with metadata\"\"\"\n\t\tself.messages.append(ManagedMessage(message=message, metadata=metadata))\n\t\tself.total_tokens += metadata.input_tokens\n\n\tdef remove_message(self, index: int = -1) -> None:\n\t\t\"\"\"Remove last message from history\"\"\"\n\t\tif self.messages:\n\t\t\tmsg = self.messages.pop(index)\n\t\t\tself.total_tokens -= msg.metadata.input_tokens\n",
    "isBinary": "false"
  },
  "browser_use/dom/buildDomTree.js": {
    "code": "(doHighlightElements = true) => {\n\tlet highlightIndex = 0; // Reset highlight index\n\n\tfunction highlightElement(element, index, parentIframe = null) {\n\t\t// Create or get highlight container\n\t\tlet container = document.getElementById(\"playwright-highlight-container\");\n\t\tif (!container) {\n\t\t\tcontainer = document.createElement(\"div\");\n\t\t\tcontainer.id = \"playwright-highlight-container\";\n\t\t\tcontainer.style.position = \"fixed\";\n\t\t\tcontainer.style.pointerEvents = \"none\";\n\t\t\tcontainer.style.top = \"0\";\n\t\t\tcontainer.style.left = \"0\";\n\t\t\tcontainer.style.width = \"100%\";\n\t\t\tcontainer.style.height = \"100%\";\n\t\t\tcontainer.style.zIndex = \"2147483647\"; // Maximum z-index value\n\t\t\tdocument.documentElement.appendChild(container);\n\t\t}\n\n\t\t// Generate a color based on the index\n\t\tconst colors = [\n\t\t\t\"#FF0000\",\n\t\t\t\"#00FF00\",\n\t\t\t\"#0000FF\",\n\t\t\t\"#FFA500\",\n\t\t\t\"#800080\",\n\t\t\t\"#008080\",\n\t\t\t\"#FF69B4\",\n\t\t\t\"#4B0082\",\n\t\t\t\"#FF4500\",\n\t\t\t\"#2E8B57\",\n\t\t\t\"#DC143C\",\n\t\t\t\"#4682B4\",\n\t\t];\n\t\tconst colorIndex = index % colors.length;\n\t\tconst baseColor = colors[colorIndex];\n\t\tconst backgroundColor = `${baseColor}1A`; // 10% opacity version of the color\n\n\t\t// Create highlight overlay\n\t\tconst overlay = document.createElement(\"div\");\n\t\toverlay.style.position = \"absolute\";\n\t\toverlay.style.border = `2px solid ${baseColor}`;\n\t\toverlay.style.backgroundColor = backgroundColor;\n\t\toverlay.style.pointerEvents = \"none\";\n\t\toverlay.style.boxSizing = \"border-box\";\n\n\t\t// Position overlay based on element\n\t\tconst rect = element.getBoundingClientRect();\n\t\tlet top = rect.top;\n\t\tlet left = rect.left;\n\n\t\t// Adjust position if element is inside an iframe\n\t\tif (parentIframe) {\n\t\t\tconst iframeRect = parentIframe.getBoundingClientRect();\n\t\t\ttop += iframeRect.top;\n\t\t\tleft += iframeRect.left;\n\t\t}\n\n\t\toverlay.style.top = `${top}px`;\n\t\toverlay.style.left = `${left}px`;\n\t\toverlay.style.width = `${rect.width}px`;\n\t\toverlay.style.height = `${rect.height}px`;\n\n\t\t// Create label\n\t\tconst label = document.createElement(\"div\");\n\t\tlabel.className = \"playwright-highlight-label\";\n\t\tlabel.style.position = \"absolute\";\n\t\tlabel.style.background = baseColor;\n\t\tlabel.style.color = \"white\";\n\t\tlabel.style.padding = \"1px 4px\";\n\t\tlabel.style.borderRadius = \"4px\";\n\t\tlabel.style.fontSize = `${Math.min(12, Math.max(8, rect.height / 2))}px`; // Responsive font size\n\t\tlabel.textContent = index;\n\n\t\t// Calculate label position\n\t\tconst labelWidth = 20; // Approximate width\n\t\tconst labelHeight = 16; // Approximate height\n\n\t\t// Default position (top-right corner inside the box)\n\t\tlet labelTop = top + 2;\n\t\tlet labelLeft = left + rect.width - labelWidth - 2;\n\n\t\t// Adjust if box is too small\n\t\tif (rect.width < labelWidth + 4 || rect.height < labelHeight + 4) {\n\t\t\t// Position outside the box if it's too small\n\t\t\tlabelTop = top - labelHeight - 2;\n\t\t\tlabelLeft = left + rect.width - labelWidth;\n\t\t}\n\n\t\t// Ensure label stays within viewport\n\t\tif (labelTop < 0) labelTop = top + 2;\n\t\tif (labelLeft < 0) labelLeft = left + 2;\n\t\tif (labelLeft + labelWidth > window.innerWidth) {\n\t\t\tlabelLeft = left + rect.width - labelWidth - 2;\n\t\t}\n\n\t\tlabel.style.top = `${labelTop}px`;\n\t\tlabel.style.left = `${labelLeft}px`;\n\n\t\t// Add to container\n\t\tcontainer.appendChild(overlay);\n\t\tcontainer.appendChild(label);\n\n\t\t// Store reference for cleanup\n\t\telement.setAttribute(\n\t\t\t\"browser-user-highlight-id\",\n\t\t\t`playwright-highlight-${index}`,\n\t\t);\n\n\t\treturn index + 1;\n\t}\n\n\t// Helper function to generate XPath as a tree\n\tfunction getXPathTree(element, stopAtBoundary = true) {\n\t\tconst segments = [];\n\t\tlet currentElement = element;\n\n\t\twhile (currentElement && currentElement.nodeType === Node.ELEMENT_NODE) {\n\t\t\t// Stop if we hit a shadow root or iframe\n\t\t\tif (\n\t\t\t\tstopAtBoundary &&\n\t\t\t\t(currentElement.parentNode instanceof ShadowRoot ||\n\t\t\t\t\tcurrentElement.parentNode instanceof HTMLIFrameElement)\n\t\t\t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet index = 0;\n\t\t\tlet sibling = currentElement.previousSibling;\n\t\t\twhile (sibling) {\n\t\t\t\tif (\n\t\t\t\t\tsibling.nodeType === Node.ELEMENT_NODE &&\n\t\t\t\t\tsibling.nodeName === currentElement.nodeName\n\t\t\t\t) {\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\tsibling = sibling.previousSibling;\n\t\t\t}\n\n\t\t\tconst tagName = currentElement.nodeName.toLowerCase();\n\t\t\tconst xpathIndex = index > 0 ? `[${index + 1}]` : \"\";\n\t\t\tsegments.unshift(`${tagName}${xpathIndex}`);\n\n\t\t\tcurrentElement = currentElement.parentNode;\n\t\t}\n\n\t\treturn segments.join(\"/\");\n\t}\n\n\t// Helper function to check if element is accepted\n\tfunction isElementAccepted(element) {\n\t\tconst leafElementDenyList = new Set([\n\t\t\t\"svg\",\n\t\t\t\"script\",\n\t\t\t\"style\",\n\t\t\t\"link\",\n\t\t\t\"meta\",\n\t\t]);\n\t\treturn !leafElementDenyList.has(element.tagName.toLowerCase());\n\t}\n\n\t// Helper function to check if element is interactive\n\tfunction isInteractiveElement(element) {\n\t\t// Base interactive elements and roles\n\t\tconst interactiveElements = new Set([\n\t\t\t\"a\",\n\t\t\t\"button\",\n\t\t\t\"details\",\n\t\t\t\"embed\",\n\t\t\t\"input\",\n\t\t\t\"label\",\n\t\t\t\"menu\",\n\t\t\t\"menuitem\",\n\t\t\t\"object\",\n\t\t\t\"select\",\n\t\t\t\"textarea\",\n\t\t\t\"summary\",\n\t\t]);\n\n\t\tconst interactiveRoles = new Set([\n\t\t\t\"button\",\n\t\t\t\"menu\",\n\t\t\t\"menuitem\",\n\t\t\t\"link\",\n\t\t\t\"checkbox\",\n\t\t\t\"radio\",\n\t\t\t\"slider\",\n\t\t\t\"tab\",\n\t\t\t\"tabpanel\",\n\t\t\t\"textbox\",\n\t\t\t\"combobox\",\n\t\t\t\"grid\",\n\t\t\t\"listbox\",\n\t\t\t\"option\",\n\t\t\t\"progressbar\",\n\t\t\t\"scrollbar\",\n\t\t\t\"searchbox\",\n\t\t\t\"switch\",\n\t\t\t\"tree\",\n\t\t\t\"treeitem\",\n\t\t\t\"spinbutton\",\n\t\t\t\"tooltip\",\n\t\t\t\"a-button-inner\",\n\t\t\t\"a-dropdown-button\",\n\t\t\t\"click\",\n\t\t\t\"menuitemcheckbox\",\n\t\t\t\"menuitemradio\",\n\t\t\t\"a-button-text\",\n\t\t\t\"button-text\",\n\t\t\t\"button-icon\",\n\t\t\t\"button-icon-only\",\n\t\t\t\"button-text-icon-only\",\n\t\t\t\"dropdown\",\n\t\t\t\"combobox\",\n\t\t]);\n\n\t\tconst tagName = element.tagName.toLowerCase();\n\t\tconst role = element.getAttribute(\"role\");\n\t\tconst ariaRole = element.getAttribute(\"aria-role\");\n\t\tconst tabIndex = element.getAttribute(\"tabindex\");\n\n\t\t// Basic role/attribute checks\n\t\tconst hasInteractiveRole =\n\t\t\tinteractiveElements.has(tagName) ||\n\t\t\tinteractiveRoles.has(role) ||\n\t\t\tinteractiveRoles.has(ariaRole) ||\n\t\t\t(tabIndex !== null && tabIndex !== \"-1\") ||\n\t\t\telement.getAttribute(\"data-action\") === \"a-dropdown-select\" ||\n\t\t\telement.getAttribute(\"data-action\") === \"a-dropdown-button\";\n\n\t\tif (hasInteractiveRole) return true;\n\n\t\t// Get computed style\n\t\tconst style = window.getComputedStyle(element);\n\n\t\t// Check if element has click-like styling\n\t\t// const hasClickStyling = style.cursor === 'pointer' ||\n\t\t//     element.style.cursor === 'pointer' ||\n\t\t//     style.pointerEvents !== 'none';\n\n\t\t// Check for event listeners\n\t\tconst hasClickHandler =\n\t\t\telement.onclick !== null ||\n\t\t\telement.getAttribute(\"onclick\") !== null ||\n\t\t\telement.hasAttribute(\"ng-click\") ||\n\t\t\telement.hasAttribute(\"@click\") ||\n\t\t\telement.hasAttribute(\"v-on:click\");\n\n\t\t// Helper function to safely get event listeners\n\t\tfunction getEventListeners(el) {\n\t\t\ttry {\n\t\t\t\t// Try to get listeners using Chrome DevTools API\n\t\t\t\treturn window.getEventListeners?.(el) || {};\n\t\t\t} catch (e) {\n\t\t\t\t// Fallback: check for common event properties\n\t\t\t\tconst listeners = {};\n\n\t\t\t\t// List of common event types to check\n\t\t\t\tconst eventTypes = [\n\t\t\t\t\t\"click\",\n\t\t\t\t\t\"mousedown\",\n\t\t\t\t\t\"mouseup\",\n\t\t\t\t\t\"touchstart\",\n\t\t\t\t\t\"touchend\",\n\t\t\t\t\t\"keydown\",\n\t\t\t\t\t\"keyup\",\n\t\t\t\t\t\"focus\",\n\t\t\t\t\t\"blur\",\n\t\t\t\t];\n\n\t\t\t\tfor (const type of eventTypes) {\n\t\t\t\t\tconst handler = el[`on${type}`];\n\t\t\t\t\tif (handler) {\n\t\t\t\t\t\tlisteners[type] = [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlistener: handler,\n\t\t\t\t\t\t\t\tuseCapture: false,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn listeners;\n\t\t\t}\n\t\t}\n\n\t\t// Check for click-related events on the element itself\n\t\tconst listeners = getEventListeners(element);\n\t\tconst hasClickListeners =\n\t\t\tlisteners &&\n\t\t\t(listeners.click?.length > 0 ||\n\t\t\t\tlisteners.mousedown?.length > 0 ||\n\t\t\t\tlisteners.mouseup?.length > 0 ||\n\t\t\t\tlisteners.touchstart?.length > 0 ||\n\t\t\t\tlisteners.touchend?.length > 0);\n\n\t\t// Check for ARIA properties that suggest interactivity\n\t\tconst hasAriaProps =\n\t\t\telement.hasAttribute(\"aria-expanded\") ||\n\t\t\telement.hasAttribute(\"aria-pressed\") ||\n\t\t\telement.hasAttribute(\"aria-selected\") ||\n\t\t\telement.hasAttribute(\"aria-checked\");\n\n\t\t// Check for form-related functionality\n\t\tconst isFormRelated =\n\t\t\telement.form !== undefined ||\n\t\t\telement.hasAttribute(\"contenteditable\") ||\n\t\t\tstyle.userSelect !== \"none\";\n\n\t\t// Check if element is draggable\n\t\tconst isDraggable =\n\t\t\telement.draggable || element.getAttribute(\"draggable\") === \"true\";\n\n\t\treturn (\n\t\t\thasAriaProps ||\n\t\t\t// hasClickStyling ||\n\t\t\thasClickHandler ||\n\t\t\thasClickListeners ||\n\t\t\t// isFormRelated ||\n\t\t\tisDraggable\n\t\t);\n\t}\n\n\t// Helper function to check if element is visible\n\tfunction isElementVisible(element) {\n\t\tconst style = window.getComputedStyle(element);\n\t\treturn (\n\t\t\telement.offsetWidth > 0 &&\n\t\t\telement.offsetHeight > 0 &&\n\t\t\tstyle.visibility !== \"hidden\" &&\n\t\t\tstyle.display !== \"none\"\n\t\t);\n\t}\n\n\t// Helper function to check if element is the top element at its position\n\tfunction isTopElement(element) {\n\t\t// Find the correct document context and root element\n\t\tconst doc = element.ownerDocument;\n\n\t\t// If we're in an iframe, elements are considered top by default\n\t\tif (doc !== window.document) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// For shadow DOM, we need to check within its own root context\n\t\tconst shadowRoot = element.getRootNode();\n\t\tif (shadowRoot instanceof ShadowRoot) {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tconst point = {\n\t\t\t\tx: rect.left + rect.width / 2,\n\t\t\t\ty: rect.top + rect.height / 2,\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\t// Use shadow root's elementFromPoint to check within shadow DOM context\n\t\t\t\tconst topEl = shadowRoot.elementFromPoint(point.x, point.y);\n\t\t\t\tif (!topEl) return false;\n\n\t\t\t\t// Check if the element or any of its parents match our target element\n\t\t\t\tlet current = topEl;\n\t\t\t\twhile (current && current !== shadowRoot) {\n\t\t\t\t\tif (current === element) return true;\n\t\t\t\t\tcurrent = current.parentElement;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t} catch (e) {\n\t\t\t\treturn true; // If we can't determine, consider it visible\n\t\t\t}\n\t\t}\n\n\t\t// Regular DOM elements\n\t\tconst rect = element.getBoundingClientRect();\n\t\tconst point = {\n\t\t\tx: rect.left + rect.width / 2,\n\t\t\ty: rect.top + rect.height / 2,\n\t\t};\n\n\t\ttry {\n\t\t\tconst topEl = document.elementFromPoint(point.x, point.y);\n\t\t\tif (!topEl) return false;\n\n\t\t\tlet current = topEl;\n\t\t\twhile (current && current !== document.documentElement) {\n\t\t\t\tif (current === element) return true;\n\t\t\t\tcurrent = current.parentElement;\n\t\t\t}\n\t\t\treturn false;\n\t\t} catch (e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// Helper function to check if text node is visible\n\tfunction isTextNodeVisible(textNode) {\n\t\tconst range = document.createRange();\n\t\trange.selectNodeContents(textNode);\n\t\tconst rect = range.getBoundingClientRect();\n\n\t\treturn (\n\t\t\trect.width !== 0 &&\n\t\t\trect.height !== 0 &&\n\t\t\trect.top >= 0 &&\n\t\t\trect.top <= window.innerHeight &&\n\t\t\ttextNode.parentElement?.checkVisibility({\n\t\t\t\tcheckOpacity: true,\n\t\t\t\tcheckVisibilityCSS: true,\n\t\t\t})\n\t\t);\n\t}\n\n\t// Function to traverse the DOM and create nested JSON\n\tfunction buildDomTree(node, parentIframe = null) {\n\t\tif (!node) return null;\n\n\t\t// Special case for text nodes\n\t\tif (node.nodeType === Node.TEXT_NODE) {\n\t\t\tconst textContent = node.textContent.trim();\n\t\t\tif (textContent && isTextNodeVisible(node)) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"TEXT_NODE\",\n\t\t\t\t\ttext: textContent,\n\t\t\t\t\tisVisible: true,\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t// Check if element is accepted\n\t\tif (node.nodeType === Node.ELEMENT_NODE && !isElementAccepted(node)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst nodeData = {\n\t\t\ttagName: node.tagName ? node.tagName.toLowerCase() : null,\n\t\t\tattributes: {},\n\t\t\txpath:\n\t\t\t\tnode.nodeType === Node.ELEMENT_NODE ? getXPathTree(node, true) : null,\n\t\t\tchildren: [],\n\t\t};\n\n\t\t// Copy all attributes if the node is an element\n\t\tif (node.nodeType === Node.ELEMENT_NODE && node.attributes) {\n\t\t\t// Use getAttributeNames() instead of directly iterating attributes\n\t\t\tconst attributeNames = node.getAttributeNames?.() || [];\n\t\t\tfor (const name of attributeNames) {\n\t\t\t\tnodeData.attributes[name] = node.getAttribute(name);\n\t\t\t}\n\t\t}\n\n\t\tif (node.nodeType === Node.ELEMENT_NODE) {\n\t\t\tconst isInteractive = isInteractiveElement(node);\n\t\t\tconst isVisible = isElementVisible(node);\n\t\t\tconst isTop = isTopElement(node);\n\n\t\t\tnodeData.isInteractive = isInteractive;\n\t\t\tnodeData.isVisible = isVisible;\n\t\t\tnodeData.isTopElement = isTop;\n\n\t\t\t// Highlight if element meets all criteria and highlighting is enabled\n\t\t\tif (isInteractive && isVisible && isTop) {\n\t\t\t\tnodeData.highlightIndex = highlightIndex++;\n\t\t\t\tif (doHighlightElements) {\n\t\t\t\t\thighlightElement(node, nodeData.highlightIndex, parentIframe);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Only add iframeContext if we're inside an iframe\n\t\t// if (parentIframe) {\n\t\t//     nodeData.iframeContext = `iframe[src=\"${parentIframe.src || ''}\"]`;\n\t\t// }\n\n\t\t// Only add shadowRoot field if it exists\n\t\tif (node.shadowRoot) {\n\t\t\tnodeData.shadowRoot = true;\n\t\t}\n\n\t\t// Handle shadow DOM\n\t\tif (node.shadowRoot) {\n\t\t\tconst shadowChildren = Array.from(node.shadowRoot.childNodes).map(\n\t\t\t\t(child) => buildDomTree(child, parentIframe),\n\t\t\t);\n\t\t\tnodeData.children.push(...shadowChildren);\n\t\t}\n\n\t\t// Handle iframes\n\t\tif (node.tagName === \"IFRAME\") {\n\t\t\ttry {\n\t\t\t\tconst iframeDoc = node.contentDocument || node.contentWindow.document;\n\t\t\t\tif (iframeDoc) {\n\t\t\t\t\tconst iframeChildren = Array.from(iframeDoc.body.childNodes).map(\n\t\t\t\t\t\t(child) => buildDomTree(child, node),\n\t\t\t\t\t);\n\t\t\t\t\tnodeData.children.push(...iframeChildren);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconsole.warn(\"Unable to access iframe:\", node);\n\t\t\t}\n\t\t} else {\n\t\t\tconst children = Array.from(node.childNodes).map((child) =>\n\t\t\t\tbuildDomTree(child, parentIframe),\n\t\t\t);\n\t\t\tnodeData.children.push(...children);\n\t\t}\n\n\t\treturn nodeData;\n\t}\n\n\treturn buildDomTree(document.body);\n};\n",
    "isBinary": "false"
  },
  "browser_use/browser/browser.py": {
    "code": "\"\"\"\nPlaywright browser on steroids.\n\"\"\"\n\nimport asyncio\nimport logging\nfrom dataclasses import dataclass, field\n\nfrom playwright._impl._api_structures import ProxySettings\nfrom playwright.async_api import Browser as PlaywrightBrowser\nfrom playwright.async_api import (\n\tPlaywright,\n\tasync_playwright,\n)\n\nfrom browser_use.browser.context import BrowserContext, BrowserContextConfig\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass BrowserConfig:\n\t\"\"\"\n\tConfiguration for the Browser.\n\n\tDefault values:\n\t\theadless: True\n\t\t\tWhether to run browser in headless mode\n\n\t\tdisable_security: False\n\t\t\tDisable browser security features\n\n\t\textra_chromium_args: []\n\t\t\tExtra arguments to pass to the browser\n\n\t\twss_url: None\n\t\t\tConnect to a browser instance via WebSocket\n\n\t\tchrome_instance_path: None\n\t\t\tPath to a Chrome instance to use to connect to your normal browser\n\t\t\te.g. '/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome'\n\t\"\"\"\n\n\theadless: bool = False\n\tdisable_security: bool = True\n\textra_chromium_args: list[str] = field(default_factory=list)\n\tchrome_instance_path: str | None = None\n\twss_url: str | None = None\n\n\tproxy: ProxySettings | None = field(default=None)\n\tnew_context_config: BrowserContextConfig = field(default_factory=BrowserContextConfig)\n\n\n# @singleton: TODO - think about id singleton makes sense here\n# @dev By default this is a singleton, but you can create multiple instances if you need to.\nclass Browser:\n\t\"\"\"\n\tPlaywright browser on steroids.\n\n\tThis is persistant browser factory that can spawn multiple browser contexts.\n\tIt is recommended to use only one instance of Browser per your application (RAM usage will grow otherwise).\n\t\"\"\"\n\n\tdef __init__(\n\t\tself,\n\t\tconfig: BrowserConfig = BrowserConfig(),\n\t):\n\t\tlogger.debug('Initializing new browser')\n\t\tself.config = config\n\t\tself.playwright: Playwright | None = None\n\t\tself.playwright_browser: PlaywrightBrowser | None = None\n\n\tasync def new_context(\n\t\tself, config: BrowserContextConfig = BrowserContextConfig()\n\t) -> BrowserContext:\n\t\t\"\"\"Create a browser context\"\"\"\n\t\treturn BrowserContext(config=config, browser=self)\n\n\tasync def get_playwright_browser(self) -> PlaywrightBrowser:\n\t\t\"\"\"Get a browser context\"\"\"\n\t\tif self.playwright_browser is None:\n\t\t\treturn await self._init()\n\n\t\treturn self.playwright_browser\n\n\tasync def _init(self):\n\t\t\"\"\"Initialize the browser session\"\"\"\n\t\tplaywright = await async_playwright().start()\n\t\tbrowser = await self._setup_browser(playwright)\n\n\t\tself.playwright = playwright\n\t\tself.playwright_browser = browser\n\n\t\treturn self.playwright_browser\n\n\tasync def _setup_browser(self, playwright: Playwright) -> PlaywrightBrowser:\n\t\t\"\"\"Sets up and returns a Playwright Browser instance with anti-detection measures.\"\"\"\n\t\tif self.config.wss_url:\n\t\t\tbrowser = await playwright.chromium.connect(self.config.wss_url)\n\t\t\treturn browser\n\t\telif self.config.chrome_instance_path:\n\t\t\timport subprocess\n\n\t\t\timport requests\n\n\t\t\ttry:\n\t\t\t\t# Check if browser is already running\n\t\t\t\tresponse = requests.get('http://localhost:9222/json/version', timeout=2)\n\t\t\t\tif response.status_code == 200:\n\t\t\t\t\tlogger.info('Reusing existing Chrome instance')\n\t\t\t\t\tbrowser = await playwright.chromium.connect_over_cdp(\n\t\t\t\t\t\tendpoint_url='http://localhost:9222',\n\t\t\t\t\t\ttimeout=20000,  # 20 second timeout for connection\n\t\t\t\t\t)\n\t\t\t\t\treturn browser\n\t\t\texcept requests.ConnectionError:\n\t\t\t\tlogger.debug('No existing Chrome instance found, starting a new one')\n\n\t\t\t# Start a new Chrome instance\n\t\t\tsubprocess.Popen(\n\t\t\t\t[\n\t\t\t\t\tself.config.chrome_instance_path,\n\t\t\t\t\t'--remote-debugging-port=9222',\n\t\t\t\t],\n\t\t\t\tstdout=subprocess.DEVNULL,\n\t\t\t\tstderr=subprocess.DEVNULL,\n\t\t\t)\n\n\t\t\t# Attempt to connect again after starting a new instance\n\t\t\ttry:\n\t\t\t\tbrowser = await playwright.chromium.connect_over_cdp(\n\t\t\t\t\tendpoint_url='http://localhost:9222',\n\t\t\t\t\ttimeout=20000,  # 20 second timeout for connection\n\t\t\t\t)\n\t\t\t\treturn browser\n\t\t\texcept Exception as e:\n\t\t\t\tlogger.error(f'Failed to start a new Chrome instance.: {str(e)}')\n\t\t\t\traise RuntimeError(\n\t\t\t\t\t' To start chrome in Debug mode, you need to close all existing Chrome instances and try again otherwise we can not connect to the instance.'\n\t\t\t\t)\n\n\t\telse:\n\t\t\ttry:\n\t\t\t\tdisable_security_args = []\n\t\t\t\tif self.config.disable_security:\n\t\t\t\t\tdisable_security_args = [\n\t\t\t\t\t\t'--disable-web-security',\n\t\t\t\t\t\t'--disable-site-isolation-trials',\n\t\t\t\t\t\t'--disable-features=IsolateOrigins,site-per-process',\n\t\t\t\t\t]\n\n\t\t\t\tbrowser = await playwright.chromium.launch(\n\t\t\t\t\theadless=self.config.headless,\n\t\t\t\t\targs=[\n\t\t\t\t\t\t'--no-sandbox',\n\t\t\t\t\t\t'--disable-blink-features=AutomationControlled',\n\t\t\t\t\t\t'--disable-infobars',\n\t\t\t\t\t\t'--disable-background-timer-throttling',\n\t\t\t\t\t\t'--disable-popup-blocking',\n\t\t\t\t\t\t'--disable-backgrounding-occluded-windows',\n\t\t\t\t\t\t'--disable-renderer-backgrounding',\n\t\t\t\t\t\t'--disable-window-activation',\n\t\t\t\t\t\t'--disable-focus-on-load',\n\t\t\t\t\t\t'--no-first-run',\n\t\t\t\t\t\t'--no-default-browser-check',\n\t\t\t\t\t\t'--no-startup-window',\n\t\t\t\t\t\t'--window-position=0,0',\n\t\t\t\t\t\t# '--window-size=1280,1000',\n\t\t\t\t\t]\n\t\t\t\t\t+ disable_security_args\n\t\t\t\t\t+ self.config.extra_chromium_args,\n\t\t\t\t\tproxy=self.config.proxy,\n\t\t\t\t)\n\n\t\t\t\treturn browser\n\t\t\texcept Exception as e:\n\t\t\t\tlogger.error(f'Failed to initialize Playwright browser: {str(e)}')\n\t\t\t\traise\n\n\tasync def close(self):\n\t\t\"\"\"Close the browser instance\"\"\"\n\t\ttry:\n\t\t\tif self.playwright_browser:\n\t\t\t\tawait self.playwright_browser.close()\n\t\t\tif self.playwright:\n\t\t\t\tawait self.playwright.stop()\n\t\texcept Exception as e:\n\t\t\tlogger.debug(f'Failed to close browser properly: {e}')\n\t\tfinally:\n\t\t\tself.playwright_browser = None\n\t\t\tself.playwright = None\n\n\tdef __del__(self):\n\t\t\"\"\"Async cleanup when object is destroyed\"\"\"\n\t\ttry:\n\t\t\tif self.playwright_browser or self.playwright:\n\t\t\t\tloop = asyncio.get_running_loop()\n\t\t\t\tif loop.is_running():\n\t\t\t\t\tloop.create_task(self.close())\n\t\t\t\telse:\n\t\t\t\t\tasyncio.run(self.close())\n\t\texcept Exception as e:\n\t\t\tlogger.debug(f'Failed to cleanup browser in destructor: {e}')\n",
    "isBinary": "false"
  },
  "browser_use/__pycache__/logging_config.cpython-313.pyc": {
    "code": "",
    "isBinary": "true"
  },
  "examples/try.py": {
    "code": "\"\"\"\nSimple try of the agent.\n\n@dev You need to add ANTHROPIC_API_KEY to your environment variables.\n\"\"\"\n\nimport os\nimport sys\n\nfrom langchain_anthropic import ChatAnthropic\nfrom langchain_openai import ChatOpenAI\n\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\nimport argparse\nimport asyncio\n\nfrom browser_use import Agent\nfrom browser_use.browser.browser import Browser, BrowserConfig\nfrom browser_use.controller.service import Controller\n\n\ndef get_llm(provider: str):\n\tif provider == 'anthropic':\n\t\treturn ChatAnthropic(\n\t\t\tmodel_name='claude-3-5-sonnet-20240620', timeout=25, stop=None, temperature=0.0\n\t\t)\n\telif provider == 'openai':\n\t\treturn ChatOpenAI(model='gpt-4o', temperature=0.0)\n\telse:\n\t\traise ValueError(f'Unsupported provider: {provider}')\n\n\ntask = 'Show the solution of y\"(z) + sin(y(z)) = 0 from wolframalpha https://www.wolframalpha.com/'\n\n\nparser = argparse.ArgumentParser()\nparser.add_argument('--query', type=str, help='The query to process', default=task)\nparser.add_argument(\n\t'--provider',\n\ttype=str,\n\tchoices=['openai', 'anthropic'],\n\tdefault='openai',\n\thelp='The model provider to use (default: openai)',\n)\n\nargs = parser.parse_args()\n\nllm = get_llm(args.provider)\n\n\nbrowser = Browser(\n\tconfig=BrowserConfig(\n\t\t# chrome_instance_path='/Applications/Google Chrome.app/Contents/MacOS/Google Chrome',\n\t)\n)\n\nagent = Agent(\n\ttask=args.query, llm=llm, controller=Controller(), browser=browser, validate_output=True\n)\n\n\nasync def main():\n\tawait agent.run(max_steps=25)\n\n\tawait browser.close()\n\n\nasyncio.run(main())\n",
    "isBinary": "false"
  },
  "examples/file_upload.py": {
    "isBinary": "false",
    "code": "import os\nimport sys\nfrom pathlib import Path\n\nfrom browser_use.agent.views import ActionResult\n\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\nimport asyncio\n\nfrom langchain_openai import ChatOpenAI\n\nfrom browser_use import Agent, Controller\nfrom browser_use.browser.browser import Browser, BrowserConfig\nfrom browser_use.browser.context import BrowserContext\n\nCV = Path.cwd() / 'examples/test_cv.txt'\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n# Initialize controller first\nbrowser = Browser(\n\tconfig=BrowserConfig(\n\t\theadless=False,\n\t\tchrome_instance_path='/Applications/Google Chrome.app/Contents/MacOS/Google Chrome',\n\t)\n)\ncontroller = Controller()\n\n\n@controller.action(\n\t'Upload file to element ',\n\trequires_browser=True,\n)\nasync def upload_file(index: int, browser: BrowserContext):\n\tpath = str(CV.absolute())\n\tdom_el = await browser.get_dom_element_by_index(index)\n\n\tif dom_el is None:\n\t\treturn ActionResult(error=f'No element found at index {index}')\n\n\tfile_upload_dom_el = dom_el.get_file_upload_element()\n\n\tif file_upload_dom_el is None:\n\t\tlogger.info(f'No file upload element found at index {index}')\n\t\treturn ActionResult(error=f'No file upload element found at index {index}')\n\n\tfile_upload_el = await browser.get_locate_element(file_upload_dom_el)\n\n\tif file_upload_el is None:\n\t\tlogger.info(f'No file upload element found at index {index}')\n\t\treturn ActionResult(error=f'No file upload element found at index {index}')\n\n\ttry:\n\t\tawait file_upload_el.set_input_files(path)\n\t\tmsg = f'Successfully uploaded file to index {index}'\n\t\tlogger.info(msg)\n\t\treturn ActionResult(extracted_content=msg)\n\texcept Exception as e:\n\t\tlogger.debug(f'Error in set_input_files: {str(e)}')\n\t\treturn ActionResult(error=f'Failed to upload file to index {index}')\n\n\n@controller.action('Close file dialog', requires_browser=True)\nasync def close_file_dialog(browser: BrowserContext):\n\tpage = await browser.get_current_page()\n\tawait page.keyboard.press('Escape')\n\n\nasync def main():\n\ttask = (\n\t\tf'go to https://kzmpmkh2zfk1ojnpxfn1.lite.vusercontent.net/'\n\t\tf' and upload to each upload field my file'\n\t)\n\n\tmodel = ChatOpenAI(model='gpt-4o')\n\tagent = Agent(\n\t\ttask=task,\n\t\tllm=model,\n\t\tcontroller=controller,\n\t\tbrowser=browser,\n\t)\n\n\tawait agent.run()\n\n\tawait browser.close()\n\n\tinput('Press Enter to close...')\n\n\nif __name__ == '__main__':\n\tasyncio.run(main())\n"
  },
  "README.md": {
    "code": "<img src=\"./static/browser-use.png\" alt=\"Browser Use Logo\" width=\"full\"/>\n\n<br/>\n\n[![GitHub stars](https://img.shields.io/github/stars/gregpr07/browser-use?style=social)](https://github.com/gregpr07/browser-use/stargazers)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n[![Python 3.11+](https://img.shields.io/badge/python-3.11+-blue.svg)](https://www.python.org/downloads/)\n[![Discord](https://img.shields.io/discord/1303749220842340412?color=7289DA&label=Discord&logo=discord&logoColor=white)](https://link.browser-use.com/discord)\n\nMake websites accessible for AI agents .\n\nBrowser use is the easiest way to connect your AI agents with the browser. If you have used Browser Use for your project feel free to show it off in our [Discord](https://link.browser-use.com/discord).\n\n# Quick start\n\nWith pip:\n\n```bash\npip install browser-use\n```\n\n(optional) install playwright:\n\n```bash\nplaywright install\n```\n\nSpin up your agent:\n\n```python\nfrom langchain_openai import ChatOpenAI\nfrom browser_use import Agent\nimport asyncio\n\nasync def main():\n    agent = Agent(\n        task=\"Find a one-way flight from Bali to Oman on 12 January 2025 on Google Flights. Return me the cheapest option.\",\n        llm=ChatOpenAI(model=\"gpt-4o\"),\n    )\n    result = await agent.run()\n    print(result)\n\nasyncio.run(main())\n```\n\nAnd don't forget to add your API keys to your `.env` file.\n\n```bash\nOPENAI_API_KEY=\nANTHROPIC_API_KEY=\n```\n\n# Demos\n\n<div style=\"font-size: 4em;\">\n    Prompt: Read my CV & find ML jobs, save them to a file, and then start applying for them in new tabs, if you need help, ask me.' (8x speed)\n</div>\n\nhttps://github.com/user-attachments/assets/171fb4d6-0355-46f2-863e-edb04a828d04\n\n<div style=\"font-size: 4em;\">\n    Prompt: Find flights on kayak.com from Zurich to Beijing from 25.12.2024 to 02.02.2025. (8x speed)\n</div>\n\n![flight search 8x 10fps](https://github.com/user-attachments/assets/ea605d4a-90e6-481e-a569-f0e0db7e6390)\n\n<div style=\"font-size: 4em;\">\n    Prompt: Look up models with a license of cc-by-sa-4.0 and sort by most likes on Hugging face, save top 5 to file. (1x speed)\n</div>\n\nhttps://github.com/user-attachments/assets/de73ee39-432c-4b97-b4e8-939fd7f323b3\n\n# Features \n\n- Vision + html extraction\n- Automatic multi-tab management\n- Extract clicked elements XPaths and repeat exact LLM actions\n- Add custom actions (e.g. save to file, push to database, notify me, get human input)\n- Self-correcting\n- Use any LLM supported by LangChain (e.g. gpt4o, gpt4o mini, claude 3.5 sonnet, llama 3.1 405b, etc.)\n- Parallelize as many agents as you want\n\n## Register custom actions\n\nIf you want to add custom actions your agent can take, you can register them like this:\n\nYou can use BOTH sync or async functions.\n\n```python\nfrom browser_use.agent.service import Agent\nfrom browser_use.browser.service import Browser\nfrom browser_use.controller.service import Controller\n\n# Initialize controller first\ncontroller = Controller()\n\n@controller.action('Ask user for information')\ndef ask_human(question: str, display_question: bool) -> str:\n\treturn input(f'\\n{question}\\nInput: ')\n```\n\nOr define your parameters using Pydantic\n\n```python\nclass JobDetails(BaseModel):\n  title: str\n  company: str\n  job_link: str\n  salary: Optional[str] = None\n\n@controller.action('Save job details which you found on page', param_model=JobDetails, requires_browser=True)\nasync def save_job(params: JobDetails, browser: Browser):\n\tprint(params)\n\n  # use the browser normally\n  page = browser.get_current_page()\n\tpage.go_to(params.job_link)\n```\n\nand then run your agent:\n\n```python\nmodel = ChatAnthropic(model_name='claude-3-5-sonnet-20240620', timeout=25, stop=None, temperature=0.3)\nagent = Agent(task=task, llm=model, controller=controller)\n\nawait agent.run()\n```\n\n## Parallelize agents\n\nIn 99% cases you should use 1 Browser instance and parallelize the agents with 1 context per agent.\nYou can also reuse the context after the agent finishes.\n\n```python\nbrowser = Browser()\n```\n\n```python\nfor i in range(10):\n    # This create a new context and automatically closes it after the agent finishes (with `__aexit__`)\n    async with browser.new_context() as context:\n        agent = Agent(task=f\"Task {i}\", llm=model, browser_context=context)\n\n        # ... reuse context\n```\n\nIf you would like to learn more about how this works under the hood you can learn more at [playwright browser-context](https://playwright.dev/python/docs/api/class-browsercontext).\n\n### Context vs Browser\n\nIf you don't specify a `browser` or `browser_context` the agent will create a new browser instance and context.\n\n## Get XPath history\n\nTo get the entire history of everything the agent has done, you can use the output of the `run` method:\n\n```python\nhistory: list[AgentHistory] = await agent.run()\n\nprint(history)\n```\n\n## Browser configuration\n\nYou can configure the browser using the `BrowserConfig` and `BrowserContextConfig` classes.\n\nThe most important options are:\n\n- `headless`: Whether to run the browser in headless mode\n- `keep_open`: Whether to keep the browser open after the script finishes\n- `disable_security`: Whether to disable browser security features (very useful if dealing with cross-origin requests like iFrames)\n- `cookies_file`: Path to a cookies file for persistence\n- `minimum_wait_page_load_time`: Minimum time to wait before getting the page state for the LLM input\n- `wait_for_network_idle_page_load_time`: Time to wait for network requests to finish before getting the page state\n- `maximum_wait_page_load_time`: Maximum time to wait for the page to load before proceeding anyway\n\n## More examples\n\nFor more examples see the [examples](examples) folder or join the [Discord](https://link.browser-use.com/discord) and show off your project.\n\n## Telemetry\n\nWe collect anonymous usage data to help us understand how the library is being used and to identify potential issues. There is no privacy risk, as no personal information is collected. We collect data with PostHog.\n\nYou can opt out of telemetry by setting the `ANONYMIZED_TELEMETRY=false` environment variable.\n\n# Contributing\n\nContributions are welcome! Feel free to open issues for bugs or feature requests.\n\n## Local Setup\n\n1. Create a virtual environment and install dependencies:\n\n```bash\n# To install all dependencies including dev\npip install . .\"[dev]\"\n```\n\n2. Add your API keys to the `.env` file:\n\n```bash\ncp .env.example .env\n```\n\nor copy the following to your `.env` file:\n\n```bash\nOPENAI_API_KEY=\nANTHROPIC_API_KEY=\n```\n\nYou can use any LLM model supported by LangChain by adding the appropriate environment variables. See [langchain models](https://python.langchain.com/docs/integrations/chat/) for available options.\n\n### Building the package\n\n```bash\nhatch build\n```\n\nFeel free to join the [Discord](https://link.browser-use.com/discord) for discussions and support.\n\n---\n\n<div align=\"center\">\n  <b>Star  this repo if you find it useful!</b><br>\n  Made with  by the Browser-Use team\n</div>\n",
    "isBinary": "false"
  },
  "examples/test_cv.txt": {
    "code": "123",
    "isBinary": "false"
  },
  "file_transformer": {
    "code": "",
    "isBinary": "true"
  },
  "examples/validate_output.py": {
    "code": "\"\"\"\nFind and apply to jobs.\n\n@dev You need to add OPENAI_API_KEY to your environment variables.\n\nAlso you have to install PyPDF2 to read pdf files: pip install PyPDF2\n\"\"\"\n\nimport os\nimport sys\n\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nimport asyncio\n\nfrom dotenv import load_dotenv\nfrom langchain_openai import ChatOpenAI\nfrom pydantic import BaseModel\n\nfrom browser_use import ActionResult, Agent, Controller\n\nload_dotenv()\n\ncontroller = Controller()\n\n\nclass DoneResult(BaseModel):\n\ttitle: str\n\tcomments: str\n\thours_since_start: int\n\n\n# we overwrite done() in this example to demonstrate the validator\n@controller.registry.action('Done with task', param_model=DoneResult)\nasync def done(params: DoneResult):\n\tresult = ActionResult(is_done=True, extracted_content=params.model_dump_json())\n\tprint(result)\n\t# NOTE: this is clearly wrong - to demonstrate the validator\n\t# return result\n\treturn 'blablabla'\n\n\nasync def main():\n\ttask = 'Go to hackernews hn and give me the top 1 post'\n\tmodel = ChatOpenAI(model='gpt-4o')\n\tagent = Agent(task=task, llm=model, controller=controller, validate_output=True)\n\t# NOTE: this should fail to demonstrate the validator\n\tawait agent.run(max_steps=5)\n\n\nif __name__ == '__main__':\n\tasyncio.run(main())\n",
    "isBinary": "false"
  },
  "examples/multiple_agents_same_browser.py": {
    "isBinary": "false",
    "code": "import os\nimport sys\n\nfrom langchain_openai import ChatOpenAI\n\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nimport asyncio\n\nfrom browser_use import Agent, Browser, Controller\n\n\n# Video: https://preview.screen.studio/share/8Elaq9sm\nasync def main():\n\t# Persist the browser state across agents\n\n\tbrowser = Browser()\n\tasync with await browser.new_context() as context:\n\t\tmodel = ChatOpenAI(model='gpt-4o')\n\n\t\t# Initialize browser agent\n\t\tagent1 = Agent(\n\t\t\ttask='Open 2 tabs with wikipedia articles about the history of the meta and one random wikipedia article.',\n\t\t\tllm=model,\n\t\t\tbrowser_context=context,\n\t\t)\n\t\tagent2 = Agent(\n\t\t\ttask='Considering all open tabs give me the names of the wikipedia article.',\n\t\t\tllm=model,\n\t\t\tbrowser_context=context,\n\t\t)\n\t\tawait agent1.run()\n\t\tawait agent2.run()\n\n\nasyncio.run(main())\n"
  },
  "examples/save_to_file_hugging_face.py": {
    "code": "import os\nimport sys\n\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nimport asyncio\nfrom typing import List, Optional\n\nfrom langchain_openai import ChatOpenAI\nfrom pydantic import BaseModel\n\nfrom browser_use.agent.service import Agent\nfrom browser_use.controller.service import Controller\n\n# Initialize controller first\ncontroller = Controller()\n\n\nclass Model(BaseModel):\n\ttitle: str\n\turl: str\n\tlikes: int\n\tlicense: str\n\n\nclass Models(BaseModel):\n\tmodels: List[Model]\n\n\n@controller.action('Save models', param_model=Models)\ndef save_models(params: Models):\n\twith open('models.txt', 'a') as f:\n\t\tfor model in params.models:\n\t\t\tf.write(f'{model.title} ({model.url}): {model.likes} likes, {model.license}\\n')\n\n\n# video: https://preview.screen.studio/share/EtOhIk0P\nasync def main():\n\ttask = f'Look up models with a license of cc-by-sa-4.0 and sort by most likes on Hugging face, save top 5 to file.'\n\n\tmodel = ChatOpenAI(model='gpt-4o')\n\tagent = Agent(task=task, llm=model, controller=controller)\n\n\tawait agent.run()\n\n\nif __name__ == '__main__':\n\tasyncio.run(main())\n",
    "isBinary": "false"
  },
  "browser_use/agent/message_manager/service.py": {
    "isBinary": "false",
    "code": "from __future__ import annotations\n\nimport logging\nfrom datetime import datetime\nfrom typing import List, Optional, Type\n\nfrom langchain_anthropic import ChatAnthropic\nfrom langchain_core.language_models import BaseChatModel\nfrom langchain_core.messages import (\n\tAIMessage,\n\tBaseMessage,\n\tHumanMessage,\n)\nfrom langchain_openai import ChatOpenAI\n\nfrom browser_use.agent.message_manager.views import MessageHistory, MessageMetadata\nfrom browser_use.agent.prompts import AgentMessagePrompt, SystemPrompt\nfrom browser_use.agent.views import ActionResult, AgentOutput, AgentStepInfo\nfrom browser_use.browser.views import BrowserState\n\nlogger = logging.getLogger(__name__)\n\n\nclass MessageManager:\n\tdef __init__(\n\t\tself,\n\t\tllm: BaseChatModel,\n\t\ttask: str,\n\t\taction_descriptions: str,\n\t\tsystem_prompt_class: Type[SystemPrompt],\n\t\tmax_input_tokens: int = 128000,\n\t\testimated_tokens_per_character: int = 3,\n\t\timage_tokens: int = 800,\n\t\tinclude_attributes: list[str] = [],\n\t\tmax_error_length: int = 400,\n\t\tmax_actions_per_step: int = 10,\n\t):\n\t\tself.llm = llm\n\t\tself.system_prompt_class = system_prompt_class\n\t\tself.max_input_tokens = max_input_tokens\n\t\tself.history = MessageHistory()\n\t\tself.task = task\n\t\tself.action_descriptions = action_descriptions\n\t\tself.ESTIMATED_TOKENS_PER_CHARACTER = estimated_tokens_per_character\n\t\tself.IMG_TOKENS = image_tokens\n\t\tself.include_attributes = include_attributes\n\t\tself.max_error_length = max_error_length\n\n\t\tsystem_message = self.system_prompt_class(\n\t\t\tself.action_descriptions,\n\t\t\tcurrent_date=datetime.now(),\n\t\t\tmax_actions_per_step=max_actions_per_step,\n\t\t).get_system_message()\n\n\t\tself._add_message_with_tokens(system_message)\n\t\tself.system_prompt = system_message\n\t\ttask_message = HumanMessage(content=f'Your task is: {task}')\n\t\tself._add_message_with_tokens(task_message)\n\n\tdef add_state_message(\n\t\tself,\n\t\tstate: BrowserState,\n\t\tresult: Optional[List[ActionResult]] = None,\n\t\tstep_info: Optional[AgentStepInfo] = None,\n\t) -> None:\n\t\t\"\"\"Add browser state as human message\"\"\"\n\n\t\t# if keep in memory, add to directly to history and add state without result\n\t\tif result:\n\t\t\tfor r in result:\n\t\t\t\tif r.include_in_memory:\n\t\t\t\t\tif r.extracted_content:\n\t\t\t\t\t\tmsg = HumanMessage(content=str(r.extracted_content))\n\t\t\t\t\t\tself._add_message_with_tokens(msg)\n\t\t\t\t\tif r.error:\n\t\t\t\t\t\tmsg = HumanMessage(content=str(r.error)[-self.max_error_length :])\n\t\t\t\t\t\tself._add_message_with_tokens(msg)\n\t\t\t\t\tresult = None  # if result in history, we dont want to add it again\n\n\t\t# otherwise add state message and result to next message (which will not stay in memory)\n\t\tstate_message = AgentMessagePrompt(\n\t\t\tstate,\n\t\t\tresult,\n\t\t\tinclude_attributes=self.include_attributes,\n\t\t\tmax_error_length=self.max_error_length,\n\t\t\tstep_info=step_info,\n\t\t).get_user_message()\n\t\tself._add_message_with_tokens(state_message)\n\n\tdef _remove_last_state_message(self) -> None:\n\t\t\"\"\"Remove last state message from history\"\"\"\n\t\tif len(self.history.messages) > 2 and isinstance(\n\t\t\tself.history.messages[-1].message, HumanMessage\n\t\t):\n\t\t\tself.history.remove_message()\n\n\tdef add_model_output(self, model_output: AgentOutput) -> None:\n\t\t\"\"\"Add model output as AI message\"\"\"\n\n\t\tcontent = model_output.model_dump_json(exclude_unset=True)\n\t\tmsg = AIMessage(content=content)\n\t\tself._add_message_with_tokens(msg)\n\n\tdef get_messages(self) -> List[BaseMessage]:\n\t\t\"\"\"Get current message list, potentially trimmed to max tokens\"\"\"\n\t\tself.cut_messages()\n\t\treturn [m.message for m in self.history.messages]\n\n\tdef cut_messages(self):\n\t\t\"\"\"Get current message list, potentially trimmed to max tokens\"\"\"\n\t\tdiff = self.history.total_tokens - self.max_input_tokens\n\t\tif diff <= 0:\n\t\t\treturn None\n\n\t\tmsg = self.history.messages[-1]\n\n\t\t# if list with image remove image\n\t\tif isinstance(msg.message.content, list):\n\t\t\ttext = ''\n\t\t\tfor item in msg.message.content:\n\t\t\t\tif 'image_url' in item:\n\t\t\t\t\tmsg.message.content.remove(item)\n\t\t\t\t\tdiff -= self.IMG_TOKENS\n\t\t\t\t\tmsg.metadata.input_tokens -= self.IMG_TOKENS\n\t\t\t\t\tself.history.total_tokens -= self.IMG_TOKENS\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\tf'Removed image with {self.IMG_TOKENS} tokens - total tokens now: {self.history.total_tokens}/{self.max_input_tokens}'\n\t\t\t\t\t)\n\t\t\t\telif 'text' in item and isinstance(item, dict):\n\t\t\t\t\ttext += item['text']\n\t\t\tmsg.message.content = text\n\t\t\tself.history.messages[-1] = msg\n\n\t\tif diff <= 0:\n\t\t\treturn None\n\n\t\t# if still over, remove text from state message proportionally to the number of tokens needed with buffer\n\t\t# Calculate the proportion of content to remove\n\t\tproportion_to_remove = diff / msg.metadata.input_tokens\n\t\tif proportion_to_remove > 0.99:\n\t\t\traise ValueError(\n\t\t\t\tf'Max token limit reached - history is too long - reduce the system prompt or task less tasks or remove old messages. '\n\t\t\t\tf'proportion_to_remove: {proportion_to_remove}'\n\t\t\t)\n\t\tlogger.debug(\n\t\t\tf'Removing {proportion_to_remove * 100:.2f}% of the last message  {proportion_to_remove * msg.metadata.input_tokens:.2f} / {msg.metadata.input_tokens:.2f} tokens)'\n\t\t)\n\n\t\tcontent = msg.message.content\n\t\tcharacters_to_remove = int(len(content) * proportion_to_remove)\n\t\tcontent = content[:-characters_to_remove]\n\n\t\t# remove tokens and old long message\n\t\tself.history.remove_message(index=-1)\n\n\t\t# new message with updated content\n\t\tmsg = HumanMessage(content=content)\n\t\tself._add_message_with_tokens(msg)\n\n\t\tlast_msg = self.history.messages[-1]\n\n\t\tlogger.debug(\n\t\t\tf'Added message with {last_msg.metadata.input_tokens} tokens - total tokens now: {self.history.total_tokens}/{self.max_input_tokens} - total messages: {len(self.history.messages)}'\n\t\t)\n\n\tdef _add_message_with_tokens(self, message: BaseMessage) -> None:\n\t\t\"\"\"Add message with token count metadata\"\"\"\n\t\ttoken_count = self._count_tokens(message)\n\t\tmetadata = MessageMetadata(input_tokens=token_count)\n\t\tself.history.add_message(message, metadata)\n\n\tdef _count_tokens(self, message: BaseMessage) -> int:\n\t\t\"\"\"Count tokens in a message using the model's tokenizer\"\"\"\n\t\ttokens = 0\n\t\tif isinstance(message.content, list):\n\t\t\tfor item in message.content:\n\t\t\t\tif 'image_url' in item:\n\t\t\t\t\ttokens += self.IMG_TOKENS\n\t\t\t\telif isinstance(item, dict) and 'text' in item:\n\t\t\t\t\ttokens += self._count_text_tokens(item['text'])\n\t\telse:\n\t\t\ttokens += self._count_text_tokens(message.content)\n\t\treturn tokens\n\n\tdef _count_text_tokens(self, text: str) -> int:\n\t\t\"\"\"Count tokens in a text string\"\"\"\n\t\tif isinstance(self.llm, (ChatOpenAI, ChatAnthropic)):\n\t\t\ttry:\n\t\t\t\ttokens = self.llm.get_num_tokens(text)\n\t\t\texcept Exception:\n\t\t\t\ttokens = (\n\t\t\t\t\tlen(text) // self.ESTIMATED_TOKENS_PER_CHARACTER\n\t\t\t\t)  # Rough estimate if no tokenizer available\n\t\telse:\n\t\t\ttokens = (\n\t\t\t\tlen(text) // self.ESTIMATED_TOKENS_PER_CHARACTER\n\t\t\t)  # Rough estimate if no tokenizer available\n\t\treturn tokens\n"
  },
  "browser_use/dom/service.py": {
    "code": "import logging\nfrom importlib import resources\nfrom typing import Optional\n\nfrom playwright.async_api import Page\n\nfrom browser_use.dom.views import (\n\tDOMBaseNode,\n\tDOMElementNode,\n\tDOMState,\n\tDOMTextNode,\n\tSelectorMap,\n)\n\nlogger = logging.getLogger(__name__)\n\n\nclass DomService:\n\tdef __init__(self, page: Page):\n\t\tself.page = page\n\t\tself.xpath_cache = {}\n\n\t# region - Clickable elements\n\tasync def get_clickable_elements(self, highlight_elements: bool = True) -> DOMState:\n\t\telement_tree = await self._build_dom_tree(highlight_elements)\n\t\tselector_map = self._create_selector_map(element_tree)\n\n\t\treturn DOMState(element_tree=element_tree, selector_map=selector_map)\n\n\tasync def _build_dom_tree(self, highlight_elements: bool) -> DOMElementNode:\n\t\tjs_code = resources.read_text('browser_use.dom', 'buildDomTree.js')\n\n\t\teval_page = await self.page.evaluate(\n\t\t\tjs_code, [highlight_elements]\n\t\t)  # This is quite big, so be careful\n\t\thtml_to_dict = self._parse_node(eval_page)\n\n\t\tif html_to_dict is None or not isinstance(html_to_dict, DOMElementNode):\n\t\t\traise ValueError('Failed to parse HTML to dictionary')\n\n\t\treturn html_to_dict\n\n\tdef _create_selector_map(self, element_tree: DOMElementNode) -> SelectorMap:\n\t\tselector_map = {}\n\n\t\tdef process_node(node: DOMBaseNode):\n\t\t\tif isinstance(node, DOMElementNode):\n\t\t\t\tif node.highlight_index is not None:\n\t\t\t\t\tselector_map[node.highlight_index] = node\n\n\t\t\t\tfor child in node.children:\n\t\t\t\t\tprocess_node(child)\n\n\t\tprocess_node(element_tree)\n\t\treturn selector_map\n\n\tdef _parse_node(\n\t\tself,\n\t\tnode_data: dict,\n\t\tparent: Optional[DOMElementNode] = None,\n\t) -> Optional[DOMBaseNode]:\n\t\tif not node_data:\n\t\t\treturn None\n\n\t\tif node_data.get('type') == 'TEXT_NODE':\n\t\t\ttext_node = DOMTextNode(\n\t\t\t\ttext=node_data['text'],\n\t\t\t\tis_visible=node_data['isVisible'],\n\t\t\t\tparent=parent,\n\t\t\t)\n\n\t\t\treturn text_node\n\n\t\ttag_name = node_data['tagName']\n\n\t\telement_node = DOMElementNode(\n\t\t\ttag_name=tag_name,\n\t\t\txpath=node_data['xpath'],\n\t\t\tattributes=node_data.get('attributes', {}),\n\t\t\tchildren=[],  # Initialize empty, will fill later\n\t\t\tis_visible=node_data.get('isVisible', False),\n\t\t\tis_interactive=node_data.get('isInteractive', False),\n\t\t\tis_top_element=node_data.get('isTopElement', False),\n\t\t\thighlight_index=node_data.get('highlightIndex'),\n\t\t\tshadow_root=node_data.get('shadowRoot', False),\n\t\t\tparent=parent,\n\t\t)\n\n\t\tchildren: list[DOMBaseNode] = []\n\t\tfor child in node_data.get('children', []):\n\t\t\tif child is not None:\n\t\t\t\tchild_node = self._parse_node(child, parent=element_node)\n\t\t\t\tif child_node is not None:\n\t\t\t\t\tchildren.append(child_node)\n\n\t\telement_node.children = children\n\n\t\treturn element_node\n\n\t# endregion\n",
    "isBinary": "false"
  },
  "browser_use/dom/__init__.py": {
    "isBinary": "false",
    "code": ""
  },
  "browser_use/telemetry/service.py": {
    "code": "import logging\nimport os\nimport uuid\nfrom pathlib import Path\n\nfrom dotenv import load_dotenv\nfrom posthog import Posthog\n\nfrom browser_use.telemetry.views import BaseTelemetryEvent\nfrom browser_use.utils import singleton\n\nload_dotenv()\n\n\nlogger = logging.getLogger(__name__)\n\nPOSTHOG_EVENT_SETTINGS = {'$process_person_profile': False}\n\n\n@singleton\nclass ProductTelemetry:\n\t\"\"\"\n\tService for capturing anonymized telemetry data.\n\n\tIf the environment variable `ANONYMIZED_TELEMETRY=False`, anonymized telemetry will be disabled.\n\t\"\"\"\n\n\tUSER_ID_PATH = str(Path.home() / '.cache' / 'browser_use' / 'telemetry_user_id')\n\tPROJECT_API_KEY = 'phc_F8JMNjW1i2KbGUTaW1unnDdLSPCoyc52SGRU0JecaUh'\n\tHOST = 'https://eu.i.posthog.com'\n\tUNKNOWN_USER_ID = 'UNKNOWN'\n\n\t_curr_user_id = None\n\n\tdef __init__(self) -> None:\n\t\ttelemetry_disabled = os.getenv('ANONYMIZED_TELEMETRY', 'true').lower() == 'false'\n\t\tself.debug_logging = os.getenv('BROWSER_USE_LOGGING_LEVEL', 'info').lower() == 'debug'\n\n\t\tif telemetry_disabled:\n\t\t\tself._posthog_client = None\n\t\telse:\n\t\t\tlogging.info(\n\t\t\t\t'Anonymized telemetry enabled. See https://github.com/gregpr07/browser-use for more information.'\n\t\t\t)\n\t\t\tself._posthog_client = Posthog(\n\t\t\t\tproject_api_key=self.PROJECT_API_KEY,\n\t\t\t\thost=self.HOST,\n\t\t\t)\n\n\t\t\t# Silence posthog's logging\n\t\t\tif not self.debug_logging:\n\t\t\t\tposthog_logger = logging.getLogger('posthog')\n\t\t\t\tposthog_logger.disabled = True\n\n\t\tif self._posthog_client is None:\n\t\t\tlogger.debug('Telemetry disabled')\n\n\tdef capture(self, event: BaseTelemetryEvent) -> None:\n\t\tif self._posthog_client is None:\n\t\t\treturn\n\n\t\tif self.debug_logging:\n\t\t\tlogger.debug(f'Telemetry event: {event.name} {event.properties}')\n\t\tself._direct_capture(event)\n\n\tdef _direct_capture(self, event: BaseTelemetryEvent) -> None:\n\t\t\"\"\"\n\t\tShould not be thread blocking because posthog magically handles it\n\t\t\"\"\"\n\t\tif self._posthog_client is None:\n\t\t\treturn\n\n\t\ttry:\n\t\t\tself._posthog_client.capture(\n\t\t\t\tself.user_id,\n\t\t\t\tevent.name,\n\t\t\t\t{**event.properties, **POSTHOG_EVENT_SETTINGS},\n\t\t\t)\n\t\texcept Exception as e:\n\t\t\tlogger.error(f'Failed to send telemetry event {event.name}: {e}')\n\n\t@property\n\tdef user_id(self) -> str:\n\t\tif self._curr_user_id:\n\t\t\treturn self._curr_user_id\n\n\t\t# File access may fail due to permissions or other reasons. We don't want to\n\t\t# crash so we catch all exceptions.\n\t\ttry:\n\t\t\tif not os.path.exists(self.USER_ID_PATH):\n\t\t\t\tos.makedirs(os.path.dirname(self.USER_ID_PATH), exist_ok=True)\n\t\t\t\twith open(self.USER_ID_PATH, 'w') as f:\n\t\t\t\t\tnew_user_id = str(uuid.uuid4())\n\t\t\t\t\tf.write(new_user_id)\n\t\t\t\tself._curr_user_id = new_user_id\n\t\t\telse:\n\t\t\t\twith open(self.USER_ID_PATH, 'r') as f:\n\t\t\t\t\tself._curr_user_id = f.read()\n\t\texcept Exception:\n\t\t\tself._curr_user_id = 'UNKNOWN_USER_ID'\n\t\treturn self._curr_user_id\n",
    "isBinary": "false"
  },
  "browser_use/agent/prompts.py": {
    "code": "from datetime import datetime\nfrom typing import List, Optional\n\nfrom langchain_core.messages import HumanMessage, SystemMessage\n\nfrom browser_use.agent.views import ActionResult, AgentStepInfo\nfrom browser_use.browser.views import BrowserState\n\n\nclass SystemPrompt:\n\tdef __init__(\n\t\tself, action_description: str, current_date: datetime, max_actions_per_step: int = 10\n\t):\n\t\tself.default_action_description = action_description\n\t\tself.current_date = current_date\n\t\tself.max_actions_per_step = max_actions_per_step\n\n\tdef important_rules(self) -> str:\n\t\t\"\"\"\n\t\tReturns the important rules for the agent.\n\t\t\"\"\"\n\t\ttext = \"\"\"\n1. RESPONSE FORMAT: You must ALWAYS respond with valid JSON in this exact format:\n   {\n     \"current_state\": {\n       \"evaluation_previous_goal\": \"Success|Failed|Unknown - Analyze the current elements and the image to check if the previous goals/actions are succesful like intended by the task. Ignore the action result. The website is the ground truth. Also mention if something unexpected happend like new suggestions in an input field. Shortly state why/why not\",\n       \"memory\": \"Description of what has been done and what you need to remember until the end of the task\",\n       \"next_goal\": \"What needs to be done with the next actions\"\n     },\n     \"action\": [\n       {\n         \"action_name\": {\n           // action-specific parameters\n         }\n       },\n       // ... more actions in sequence\n     ]\n   }\n\n2. ACTIONS: You can specify multiple actions to be executed in sequence. \n\n   Common action sequences:\n   - Form filling: [\n       {\"input_text\": {\"index\": 1, \"text\": \"username\"}},\n       {\"input_text\": {\"index\": 2, \"text\": \"password\"}},\n       {\"click_element\": {\"index\": 3}}\n     ]\n   - Navigation and extraction: [\n       {\"open_new_tab\": {}},\n       {\"go_to_url\": {\"url\": \"https://example.com\"}},\n       {\"extract_page_content\": {}}\n     ]\n\n\n3. ELEMENT INTERACTION:\n   - Only use indexes that exist in the provided element list\n   - Each element has a unique index number (e.g., \"33[:]<button>\")\n   - Elements marked with \"_[:]\" are non-interactive (for context only)\n\n4. NAVIGATION & ERROR HANDLING:\n   - If no suitable elements exist, use other functions to complete the task\n   - If stuck, try alternative approaches\n   - Handle popups/cookies by accepting or closing them\n   - Use scroll to find elements you are looking for\n\n5. TASK COMPLETION:\n   - Use the done action as the last action as soon as the task is complete\n   - Don't hallucinate actions\n   - If the task requires specific information - make sure to include everything in the done function. This is what the user will see.\n   - If you are running out of steps (current step), think about speeding it up, and ALWAYS use the done action as the last action.\n\n6. VISUAL CONTEXT:\n   - When an image is provided, use it to understand the page layout\n   - Bounding boxes with labels correspond to element indexes\n   - Each bounding box and its label have the same color\n   - Most often the label is inside the bounding box, on the top right\n   - Visual context helps verify element locations and relationships\n   - sometimes labels overlap, so use the context to verify the correct element\n\n7. Form filling:\n   - If you fill a input field and your action sequence is interrupted, most often a list with suggestions poped up under the field and you need to first select the right element from the suggestion list.\n\n8. ACTION SEQUENCING:\n   - Actions are executed in the order they appear in the list \n   - Each action should logically follow from the previous one\n   - If the page changes after an action, the sequence is interrupted and you get the new state.\n   - If content only disappears the sequence continues.\n   - Only provide the action sequence until you think the page will change.\n   - Try to be efficient, e.g. fill forms at once, or chain actions where nothing changes on the page like saving, extracting, checkboxes...\n   - only use multiple actions if it makes sense. \n\"\"\"\n\t\ttext += f'   - use maximum {self.max_actions_per_step} actions per sequence'\n\t\treturn text\n\n\tdef input_format(self) -> str:\n\t\treturn \"\"\"\nINPUT STRUCTURE:\n1. Current URL: The webpage you're currently on\n2. Available Tabs: List of open browser tabs\n3. Interactive Elements: List in the format:\n   index[:]<element_type>element_text</element_type>\n   - index: Numeric identifier for interaction\n   - element_type: HTML element type (button, input, etc.)\n   - element_text: Visible text or element description\n\nExample:\n33[:]<button>Submit Form</button>\n_[:] Non-interactive text\n\n\nNotes:\n- Only elements with numeric indexes are interactive\n- _[:] elements provide context but cannot be interacted with\n\"\"\"\n\n\tdef get_system_message(self) -> SystemMessage:\n\t\t\"\"\"\n\t\tGet the system prompt for the agent.\n\n\t\tReturns:\n\t\t    str: Formatted system prompt\n\t\t\"\"\"\n\t\ttime_str = self.current_date.strftime('%Y-%m-%d %H:%M')\n\n\t\tAGENT_PROMPT = f\"\"\"You are a precise browser automation agent that interacts with websites through structured commands. Your role is to:\n1. Analyze the provided webpage elements and structure\n2. Plan a sequence of actions to accomplish the given task\n3. Respond with valid JSON containing your action sequence and state assessment\n\nCurrent date and time: {time_str}\n\n{self.input_format()}\n\n{self.important_rules()}\n\nFunctions:\n{self.default_action_description}\n\nRemember: Your responses must be valid JSON matching the specified format. Each action in the sequence must be valid.\"\"\"\n\t\treturn SystemMessage(content=AGENT_PROMPT)\n\n\n# Example:\n# {self.example_response()}\n# Your AVAILABLE ACTIONS:\n# {self.default_action_description}\n\n\nclass AgentMessagePrompt:\n\tdef __init__(\n\t\tself,\n\t\tstate: BrowserState,\n\t\tresult: Optional[List[ActionResult]] = None,\n\t\tinclude_attributes: list[str] = [],\n\t\tmax_error_length: int = 400,\n\t\tstep_info: Optional[AgentStepInfo] = None,\n\t):\n\t\tself.state = state\n\t\tself.result = result\n\t\tself.max_error_length = max_error_length\n\t\tself.include_attributes = include_attributes\n\t\tself.step_info = step_info\n\n\tdef get_user_message(self) -> HumanMessage:\n\t\tif self.step_info:\n\t\t\tstep_info_description = (\n\t\t\t\tf'Current step: {self.step_info.step_number + 1}/{self.step_info.max_steps}'\n\t\t\t)\n\t\telse:\n\t\t\tstep_info_description = ''\n\n\t\tstate_description = f\"\"\"\n{step_info_description}\nCurrent url: {self.state.url}\nAvailable tabs:\n{self.state.tabs}\nInteractive elements:\n{self.state.element_tree.clickable_elements_to_string(include_attributes=self.include_attributes)}\n        \"\"\"\n\n\t\tif self.result:\n\t\t\tfor i, result in enumerate(self.result):\n\t\t\t\tif result.extracted_content:\n\t\t\t\t\tstate_description += (\n\t\t\t\t\t\tf'\\nResult of action {i + 1}/{len(self.result)}: {result.extracted_content}'\n\t\t\t\t\t)\n\t\t\t\tif result.error:\n\t\t\t\t\t# only use last 300 characters of error\n\t\t\t\t\terror = result.error[-self.max_error_length :]\n\t\t\t\t\tstate_description += f'\\nError of action {i + 1}/{len(self.result)}: ...{error}'\n\n\t\tif self.state.screenshot:\n\t\t\t# Format message for vision model\n\t\t\treturn HumanMessage(\n\t\t\t\tcontent=[\n\t\t\t\t\t{'type': 'text', 'text': state_description},\n\t\t\t\t\t{\n\t\t\t\t\t\t'type': 'image_url',\n\t\t\t\t\t\t'image_url': {'url': f'data:image/png;base64,{self.state.screenshot}'},\n\t\t\t\t\t},\n\t\t\t\t]\n\t\t\t)\n\n\t\treturn HumanMessage(content=state_description)\n",
    "isBinary": "false"
  },
  "browser_use/__pycache__/__init__.cpython-313.pyc": {
    "code": "",
    "isBinary": "true"
  }
}